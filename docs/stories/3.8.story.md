# Story 3.8: 编写 WebSocket 客户端使用文档和示例代码

## Status

**Done**

## Story

**As a** 用户,
**I want** 查看 WebSocket 客户端连接示例代码和使用说明,
**so that** 我可以快速集成到我的应用中。

## Acceptance Criteria

1. 在 `docs/` 目录创建 `websocket-usage.md` 文档
2. 文档包含以下章节:
   - **快速开始**: 5 分钟快速上手指南
   - **连接 WebSocket**: JavaScript 浏览器客户端示例代码
   - **发送和接收消息**: 完整的消息收发示例
   - **错误处理**: 连接失败、断线重连的处理方式
   - **消息格式**: JSON 格式说明和示例
3. 提供浏览器 JavaScript 示例:
   ```javascript
   const ws = new WebSocket('wss://domain.com/ws/{your-endpoint-id}');
   ws.onopen = () => console.log('Connected');
   ws.onmessage = (event) => console.log('Message:', event.data);
   ws.send(JSON.stringify({ type: 'message', data: 'Hello' }));
   ```
4. 提供 Node.js 示例（使用 `ws` 库）
5. 在前端端点详情页添加"查看使用文档"链接,跳转到文档页面
6. 文档页面使用 Ant Design Typography 组件渲染 markdown 内容
7. 代码示例使用代码高亮（可选，使用 `react-syntax-highlighter`）

## Tasks / Subtasks

- [x] **Task 1: 创建 WebSocket 使用文档 Markdown 文件** (AC: 1, 2, 3, 4)
  - [x] 在 `docs/` 目录创建 `websocket-usage.md` 文件
  - [x] 编写"快速开始"章节，包含 5 分钟上手指南
    - 步骤 1: 创建端点并获取 endpoint_id
    - 步骤 2: 连接 WebSocket
    - 步骤 3: 发送和接收消息
  - [x] 编写"连接 WebSocket"章节
    - 浏览器 JavaScript 原生 WebSocket 示例
    - WebSocket URL 格式说明: `wss://domain.com/ws/{endpoint_id}`
    - 连接建立事件处理: `onopen`, `onclose`, `onerror`
  - [x] 编写"发送和接收消息"章节
    - 完整的消息收发代码示例
    - 使用 `send()` 方法发送消息
    - 使用 `onmessage` 监听接收消息
    - 消息广播机制说明（不回显给发送者）
  - [x] 编写"错误处理"章节
    - 连接失败处理: `onerror` 事件
    - 断线重连逻辑示例
    - 常见错误场景和解决方案
  - [x] 编写"消息格式"章节
    - JSON 格式说明
    - 推荐的消息结构示例: `{ type: 'message', data: ... }`
    - 消息序列化和反序列化示例
  - [x] 添加 Node.js 客户端示例
    - 安装 `ws` 库: `npm install ws`
    - Node.js WebSocket 客户端代码示例
    - 环境差异说明（浏览器 vs Node.js）

- [x] **Task 2: 创建前端文档展示页面组件** (AC: 6, 7)
  - [x] 在 `packages/frontend/src/pages/` 创建 `WebSocketDocPage.tsx`
  - [x] 导入 Ant Design Typography 组件: `Typography.Title`, `Typography.Paragraph`, `Typography.Text`
  - [x] 从 `docs/websocket-usage.md` 读取 markdown 内容（方案 A: 打包到前端）
    - 使用 Vite 的 `?raw` 后缀导入 markdown 文件为字符串
    - 例如: `import markdownContent from '@/../docs/websocket-usage.md?raw'`
  - [x] 使用 `react-markdown` 库渲染 markdown 内容
    - 安装依赖: `npm install react-markdown`
    - 配置语法高亮插件: `remark-gfm`（GitHub Flavored Markdown）
  - [x] （可选）添加代码高亮支持 - 未实现,使用 CSS 样式代替
  - [x] 使用 Ant Design `Typography.Title` 作为页面标题
  - [x] 添加侧边栏大纲导航（使用 Ant Design Anchor 组件）
  - [x] 确保页面响应式布局，移动端友好

- [x] **Task 3: 在路由中注册文档页面** (AC: 5)
  - [x] 在 `packages/frontend/src/router.tsx` 中添加新路由
  - [x] 路由路径: `/docs/websocket-usage`
  - [x] 路由类型: 受保护路由（需要登录）
  - [x] 使用 `<ProtectedRoute>` 包裹组件

- [x] **Task 4: 在端点详情页添加文档链接** (AC: 5)
  - [x] 在 `packages/frontend/src/pages/EndpointDetailPage.tsx` 中添加"查看使用文档"按钮
  - [x] 使用 Ant Design `Button` 组件，类型为 `default`
  - [x] 按钮图标: 使用 `BookOutlined` 图标
  - [x] 点击跳转到 `/docs/websocket-usage` 路由（使用 `navigate`）
  - [x] 按钮位置: 放置在顶部操作栏
  - [x] 确保按钮样式与页面整体风格一致

- [x] **Task 5: 手动测试文档页面** (AC: 1-7)
  - [x] 启动前端开发服务器: `pnpm --filter @websocket-relay/frontend dev`
  - [x] 访问文档页面 `/docs/websocket-usage`
  - [x] 验证所有章节内容正确渲染
  - [x] 验证 markdown 格式（标题、列表、代码块）正确显示
  - [x] 从端点详情页点击"查看使用文档"链接，验证跳转正常
  - [x] 验证侧边栏导航和锚点跳转功能
  - [x] 验证动态域名替换功能

- [ ] **Task 6: 编写示例 WebSocket 测试客户端（可选）** (AC: 3, 4)
  - [ ] 在项目根目录创建 `examples/` 目录
  - [ ] 创建浏览器 HTML 示例: `examples/browser-client.html`
  - [ ] 创建 Node.js 示例: `examples/node-client.js`
  - [ ] 两个示例都包含完整的连接、发送、接收、错误处理逻辑
  - [ ] 在文档中添加指向示例文件的链接

- [x] **Task 7: 代码规范检查**
  - [x] 运行 `pnpm --filter @websocket-relay/frontend lint`
  - [x] 修复新增代码的 lint 错误（忽略现有错误）
  - [x] 确保新增代码符合 coding-standards.md 规范

## Dev Notes

### Previous Story Insights

**从 Story 3.7 和之前故事中学到的关键经验:**

1. **WebSocket 服务器架构**:
   - WebSocket 服务器监听端口 3001
   - 连接 URL 格式: `ws://localhost:3001/ws/{endpoint_id}`
   - 生产环境: `wss://domain.com/ws/{endpoint_id}` (通过 Nginx 反向代理)
   - 端点 ID 验证: 连接时验证 `endpoint_id` 在数据库中存在
   - 消息路由: 同一端点的客户端之间广播消息（不包括发送者本身）
   - 端点隔离: 不同端点的消息完全隔离

2. **消息格式**:
   - WebSocket 消息推荐使用 JSON 格式
   - 示例结构: `{ type: 'message', data: ... }`
   - 消息广播不回显给发送者（避免重复显示）

3. **前端架构**:
   - 前端使用 Ant Design 5.x UI 组件库
   - 使用 Vite 作为构建工具
   - 页面组件放置在 `packages/frontend/src/pages/`
   - 路由配置在 `packages/frontend/src/router.tsx`

4. **已有的 WebSocket 集成测试脚本**:
   - 项目中已有多个 WebSocket 测试脚本（如 `test-ws-connection.mjs`）
   - 可以参考这些脚本的实现来编写文档示例

[Previous Stories: docs/stories/3.1.story.md - 3.7.story.md]

---

### Tech Stack

**前端技术栈（与本故事相关）:**

- **UI 组件库**: Ant Design 5.x
  - Typography 组件: 用于文档标题、段落、文本渲染
  - Button 组件: 用于"查看使用文档"按钮
  - PageHeader 组件: 用于文档页面标题（可选）
- **Markdown 渲染**:
  - `react-markdown` (推荐): React markdown 渲染库
  - `remark-gfm`: GitHub Flavored Markdown 插件
- **代码高亮**:
  - `react-syntax-highlighter` (可选): React 代码高亮库
  - 支持多种主题（Prism, Highlight.js）
- **构建工具**: Vite 5.x
  - 支持通过 `?raw` 后缀导入文本文件
  - 例如: `import markdownContent from '@/../docs/websocket-usage.md?raw'`
- **路由**: React Router v6
  - 使用 `react-router-dom` 的 `Link` 组件进行页面跳转

**WebSocket 客户端库:**

- **浏览器**: 原生 WebSocket API（无需额外依赖）
- **Node.js**: `ws` 库（v8.x）

[Source: docs/architecture/tech-stack.md, docs/architecture/frontend-architecture.md]

---

### Project Structure

**本故事需要创建/修改的文件:**

根据 unified-project-structure.md，文件组织如下:

```
websocket-relay-platform/
├── docs/
│   └── websocket-usage.md                   # 新建: WebSocket 使用文档（Markdown）
├── packages/
│   └── frontend/
│       ├── src/
│       │   ├── pages/
│       │   │   ├── WebSocketDocPage.tsx     # 新建: 文档展示页面组件
│       │   │   └── EndpointDetailPage.tsx   # 修改: 添加"查看使用文档"链接
│       │   └── router.tsx                   # 修改: 注册文档页面路由
│       └── package.json                     # 可能修改: 添加 react-markdown 等依赖
├── examples/ (可选)
│   ├── browser-client.html                  # 新建: 浏览器客户端示例
│   └── node-client.js                       # 新建: Node.js 客户端示例
└── package.json
```

**命名规范:**
- 页面组件使用 PascalCase: `WebSocketDocPage.tsx`
- Markdown 文件使用 kebab-case: `websocket-usage.md`
- 示例文件使用 kebab-case: `browser-client.html`, `node-client.js`

[Source: docs/architecture/unified-project-structure.md, docs/architecture/coding-standards.md#Naming Conventions]

---

### Frontend Component Architecture

**文档页面组件设计:**

根据 frontend-architecture.md，文档页面应遵循以下设计:

**1. 页面组件职责:**
- 负责渲染 markdown 内容
- 提供页面布局和导航
- 处理响应式布局

**2. 组件结构示例:**

```tsx
// packages/frontend/src/pages/WebSocketDocPage.tsx
import React from 'react';
import { Typography, Card, Layout } from 'antd';
import ReactMarkdown from 'react-markdown';
import remarkGfm from 'remark-gfm';
import markdownContent from '@/../docs/websocket-usage.md?raw';

const { Title } = Typography;
const { Content } = Layout;

const WebSocketDocPage: React.FC = () => {
  return (
    <Content style={{ padding: '24px' }}>
      <Card>
        <Title level={2}>WebSocket 使用文档</Title>
        <ReactMarkdown remarkPlugins={[remarkGfm]}>
          {markdownContent}
        </ReactMarkdown>
      </Card>
    </Content>
  );
};

export default WebSocketDocPage;
```

**3. 代码高亮配置（可选）:**

```tsx
import { Prism as SyntaxHighlighter } from 'react-syntax-highlighter';
import { oneDark } from 'react-syntax-highlighter/dist/esm/styles/prism';

const CodeBlock = ({ language, value }: { language: string; value: string }) => {
  return (
    <SyntaxHighlighter language={language} style={oneDark}>
      {value}
    </SyntaxHighlighter>
  );
};

// 在 ReactMarkdown 中使用:
<ReactMarkdown
  remarkPlugins={[remarkGfm]}
  components={{
    code({ node, inline, className, children, ...props }) {
      const match = /language-(\w+)/.exec(className || '');
      return !inline && match ? (
        <CodeBlock language={match[1]} value={String(children).replace(/\n$/, '')} />
      ) : (
        <code className={className} {...props}>
          {children}
        </code>
      );
    },
  }}
>
  {markdownContent}
</ReactMarkdown>
```

[Source: docs/architecture/frontend-architecture.md#Component Organization]

---

### Routing Configuration

**前端路由注册:**

根据 frontend-architecture.md，需要在 `router.tsx` 中添加新路由:

**路由配置示例:**

```tsx
// packages/frontend/src/router.tsx
import WebSocketDocPage from '@/pages/WebSocketDocPage';

// 在路由配置中添加:
{
  path: '/docs/websocket-usage',
  element: <ProtectedRoute><WebSocketDocPage /></ProtectedRoute>,
}
```

**路由类型:**
- 受保护路由（需要登录）: 使用 `<ProtectedRoute>` 包裹
- 如果文档应该公开访问，可以不使用 `<ProtectedRoute>`（根据产品需求决定）

**面包屑导航（可选）:**
- Dashboard > WebSocket 使用文档

[Source: docs/architecture/frontend-architecture.md#Routing]

---

### Documentation Content Structure

**WebSocket 使用文档的章节结构:**

根据 AC 要求，文档应包含以下章节:

**1. 快速开始（5 分钟上手指南）:**
- 步骤 1: 创建端点
  - 登录系统，进入 Dashboard
  - 点击"创建端点"按钮
  - 获取 endpoint_id（例如: `abc123xyz`）
- 步骤 2: 连接 WebSocket
  - 使用浏览器或 Node.js 客户端连接
  - WebSocket URL: `wss://domain.com/ws/abc123xyz`
- 步骤 3: 发送和接收消息
  - 简单的消息收发示例

**2. 连接 WebSocket（详细说明）:**
- WebSocket URL 格式: `wss://domain.com/ws/{endpoint_id}`
- 浏览器 JavaScript 示例（完整代码）
- 连接事件处理:
  - `onopen`: 连接成功
  - `onclose`: 连接关闭
  - `onerror`: 连接错误
- 连接验证机制说明（endpoint_id 验证）

**3. 发送和接收消息:**
- 发送消息: `ws.send(JSON.stringify({ ... }))`
- 接收消息: `ws.onmessage = (event) => { ... }`
- 消息广播机制: 发送者不会收到自己的消息（不回显）
- 完整的消息收发代码示例

**4. 错误处理:**
- 连接失败处理: `onerror` 事件
- 断线重连逻辑示例（指数退避算法）
- 常见错误场景:
  - Invalid endpoint（endpoint_id 不存在）
  - 网络连接失败
  - 服务器维护

**5. 消息格式:**
- 推荐使用 JSON 格式
- 消息结构示例:
  ```json
  {
    "type": "message",
    "data": "Hello, World!",
    "timestamp": "2025-10-28T10:30:00Z"
  }
  ```
- 序列化: `JSON.stringify()`
- 反序列化: `JSON.parse(event.data)`

**6. Node.js 客户端示例:**
- 安装 `ws` 库: `npm install ws`
- 完整的 Node.js 客户端代码
- 环境差异说明（浏览器 vs Node.js）

[Source: PRD Epic 3 Story 3.8 AC]

---

### WebSocket Connection URL Format

**WebSocket URL 格式说明:**

根据 Story 3.1 和 3.2 的实现:

**开发环境:**
```
ws://localhost:3001/ws/{endpoint_id}
```

**生产环境:**
```
wss://domain.com/ws/{endpoint_id}
```

**说明:**
- `ws://`: 非加密 WebSocket 协议（开发环境）
- `wss://`: 加密 WebSocket 协议（生产环境，通过 Nginx SSL 终止）
- `localhost:3001`: WebSocket 服务器监听端口
- `/ws/{endpoint_id}`: 路径格式，`{endpoint_id}` 是端点的唯一标识符

**endpoint_id 获取方式:**
- 用户在 Dashboard 创建端点后，系统生成唯一的 `endpoint_id`
- 端点详情页显示 WebSocket URL（包含 endpoint_id）

[Source: docs/stories/3.1.story.md, docs/stories/3.2.story.md]

---

### Ant Design Typography Components

**文档页面使用的 Ant Design 组件:**

根据 AC 和 tech-stack.md:

**1. Typography 组件:**

```tsx
import { Typography } from 'antd';
const { Title, Paragraph, Text } = Typography;

// 使用示例:
<Title level={1}>WebSocket 使用文档</Title>
<Title level={2}>快速开始</Title>
<Paragraph>
  这是一段说明文字...
</Paragraph>
<Text code>ws://localhost:3001/ws/abc123</Text>
```

**2. Card 组件（用于容器）:**

```tsx
import { Card } from 'antd';

<Card title="WebSocket 使用文档" bordered={true}>
  {/* 文档内容 */}
</Card>
```

**3. Button 组件（用于"查看使用文档"链接）:**

```tsx
import { Button } from 'antd';
import { BookOutlined } from '@ant-design/icons';
import { Link } from 'react-router-dom';

<Link to="/docs/websocket-usage">
  <Button type="link" icon={<BookOutlined />}>
    查看使用文档
  </Button>
</Link>
```

[Source: docs/architecture/tech-stack.md#UI Component Library]

---

### Vite Raw Import

**Vite 支持直接导入文本文件:**

根据 Vite 文档和 tech-stack.md:

**导入 Markdown 文件为字符串:**

```typescript
// 使用 ?raw 后缀导入文件内容为字符串
import markdownContent from '@/../docs/websocket-usage.md?raw';

// markdownContent 是字符串类型，包含文件的完整内容
console.log(markdownContent); // "# WebSocket 使用文档\n\n..."
```

**路径说明:**
- `@/`: Vite 配置的别名，通常指向 `src/` 目录
- `@/../`: 向上一级，访问 `packages/frontend/` 外的文件
- 例如: `packages/frontend/src/` -> `@/`
- 例如: `docs/` -> `@/../../../docs/`（从 monorepo 根目录）

**替代方案（如果 ?raw 不可用）:**
- 使用 `fetch()` 从静态资源目录加载 markdown 文件
- 将 markdown 内容直接嵌入 TypeScript 字符串常量

[Source: Vite 官方文档, docs/architecture/tech-stack.md#Build Tool]

---

### Code Syntax Highlighting (Optional)

**代码高亮库选择:**

根据 AC 和前端最佳实践:

**推荐库: `react-syntax-highlighter`**

**安装:**
```bash
npm install react-syntax-highlighter @types/react-syntax-highlighter
```

**使用示例:**

```tsx
import { Prism as SyntaxHighlighter } from 'react-syntax-highlighter';
import { oneDark } from 'react-syntax-highlighter/dist/esm/styles/prism';

<SyntaxHighlighter language="javascript" style={oneDark}>
  {`const ws = new WebSocket('wss://domain.com/ws/abc123');
ws.onopen = () => console.log('Connected');`}
</SyntaxHighlighter>
```

**集成到 `react-markdown`:**

```tsx
<ReactMarkdown
  remarkPlugins={[remarkGfm]}
  components={{
    code({ node, inline, className, children, ...props }) {
      const match = /language-(\w+)/.exec(className || '');
      return !inline && match ? (
        <SyntaxHighlighter language={match[1]} style={oneDark}>
          {String(children).replace(/\n$/, '')}
        </SyntaxHighlighter>
      ) : (
        <code className={className} {...props}>
          {children}
        </code>
      );
    },
  }}
>
  {markdownContent}
</ReactMarkdown>
```

**主题选择:**
- `oneDark`: 深色主题，类似 VS Code
- `prism`: 浅色主题，清晰易读
- `tomorrow`: 中性主题，多色彩

**注意:** AC 中标记为"可选"，MVP 阶段可以跳过高亮，使用 Ant Design 的 `Typography.Text code` 即可。

[Source: AC 7, 前端最佳实践]

---

### Example Code Snippets

**文档中需要包含的示例代码:**

**1. 浏览器 JavaScript 客户端（完整示例）:**

```javascript
// 创建 WebSocket 连接
const ws = new WebSocket('wss://domain.com/ws/your-endpoint-id');

// 连接成功事件
ws.onopen = () => {
  console.log('WebSocket 连接已建立');

  // 发送消息
  const message = {
    type: 'message',
    data: 'Hello from browser!',
    timestamp: new Date().toISOString(),
  };
  ws.send(JSON.stringify(message));
};

// 接收消息事件
ws.onmessage = (event) => {
  console.log('收到消息:', event.data);

  // 解析 JSON 消息
  try {
    const message = JSON.parse(event.data);
    console.log('消息类型:', message.type);
    console.log('消息内容:', message.data);
  } catch (error) {
    console.error('消息解析失败:', error);
  }
};

// 连接关闭事件
ws.onclose = (event) => {
  console.log('WebSocket 连接已关闭', event.code, event.reason);
};

// 连接错误事件
ws.onerror = (error) => {
  console.error('WebSocket 错误:', error);
};
```

**2. Node.js 客户端示例:**

```javascript
// Node.js WebSocket 客户端示例
const WebSocket = require('ws');

const ws = new WebSocket('wss://domain.com/ws/your-endpoint-id');

ws.on('open', () => {
  console.log('WebSocket 连接已建立');

  // 发送消息
  const message = {
    type: 'message',
    data: 'Hello from Node.js!',
    timestamp: new Date().toISOString(),
  };
  ws.send(JSON.stringify(message));
});

ws.on('message', (data) => {
  console.log('收到消息:', data.toString());

  // 解析 JSON 消息
  try {
    const message = JSON.parse(data.toString());
    console.log('消息类型:', message.type);
    console.log('消息内容:', message.data);
  } catch (error) {
    console.error('消息解析失败:', error);
  }
});

ws.on('close', (code, reason) => {
  console.log('WebSocket 连接已关闭', code, reason.toString());
});

ws.on('error', (error) => {
  console.error('WebSocket 错误:', error);
});
```

**3. 断线重连逻辑示例:**

```javascript
let ws;
let reconnectAttempts = 0;
const maxReconnectAttempts = 5;
const reconnectDelay = 2000; // 2 秒

function connect() {
  ws = new WebSocket('wss://domain.com/ws/your-endpoint-id');

  ws.onopen = () => {
    console.log('连接成功');
    reconnectAttempts = 0; // 重置重连次数
  };

  ws.onclose = () => {
    console.log('连接关闭，尝试重连...');
    if (reconnectAttempts < maxReconnectAttempts) {
      reconnectAttempts++;
      setTimeout(connect, reconnectDelay * reconnectAttempts); // 指数退避
    } else {
      console.error('达到最大重连次数，停止重连');
    }
  };

  ws.onerror = (error) => {
    console.error('连接错误:', error);
  };
}

// 初始连接
connect();
```

[Source: Story 3.1-3.4 WebSocket 实现, 最佳实践]

---

### Testing

**测试策略:**

根据 testing-strategy.md:

**手动测试（必须）:**

1. **文档页面访问测试:**
   - 启动前端开发服务器: `pnpm --filter @websocket-relay/frontend dev`
   - 直接访问 `/docs/websocket-usage` 路由
   - 验证页面正常加载，markdown 内容正确渲染
   - 验证所有章节内容完整显示
   - 验证代码示例格式正确（代码块、语法高亮）

2. **路由跳转测试:**
   - 进入端点详情页 `/endpoints/:id`
   - 点击"查看使用文档"按钮/链接
   - 验证跳转到 `/docs/websocket-usage` 路由
   - 验证页面正确显示文档内容

3. **响应式布局测试:**
   - 在不同屏幕尺寸测试文档页面（Desktop, Tablet, Mobile）
   - 验证内容在小屏幕下正确换行和缩放
   - 验证代码块在移动端支持横向滚动

4. **示例代码验证测试（可选）:**
   - 复制文档中的浏览器示例代码到浏览器控制台
   - 连接到实际的端点，验证代码可以正常运行
   - 验证消息发送和接收功能正常

**前端单元测试（可选）:**

根据 testing-strategy.md，前端单元测试优先级较低，MVP 阶段可以跳过。

如果实现测试，应包含:
- 文档页面组件渲染测试
- Markdown 内容加载测试
- 路由注册测试

**测试执行命令:**

```bash
# 启动前端开发服务器
pnpm --filter @websocket-relay/frontend dev

# 运行 lint 检查
pnpm --filter @websocket-relay/frontend lint
```

[Source: docs/architecture/testing-strategy.md#Test Organization, docs/architecture/testing-strategy.md#Test Examples]

---

### Markdown Document Dependencies

**需要安装的前端依赖:**

根据 AC 和技术选型:

**必需依赖:**
```bash
# Markdown 渲染库
npm install react-markdown

# GitHub Flavored Markdown 支持
npm install remark-gfm
```

**可选依赖（代码高亮）:**
```bash
# 代码高亮库
npm install react-syntax-highlighter @types/react-syntax-highlighter
```

**package.json 更新:**

```json
{
  "dependencies": {
    "react-markdown": "^9.0.0",
    "remark-gfm": "^4.0.0",
    "react-syntax-highlighter": "^15.5.0" // 可选
  },
  "devDependencies": {
    "@types/react-syntax-highlighter": "^15.5.0" // 可选
  }
}
```

[Source: AC 6, 7, 前端技术选型]

---

### Error Handling and Edge Cases

**文档页面的错误处理:**

**1. Markdown 文件加载失败:**
- 使用 `try-catch` 包裹 markdown 导入逻辑
- 显示友好的错误提示: "文档加载失败，请刷新页面重试"
- 使用 Ant Design `Alert` 组件显示错误信息

**2. Markdown 渲染错误:**
- `react-markdown` 库通常能容错处理格式错误
- 如果渲染失败，降级显示纯文本内容

**3. 路由不存在:**
- 确保路由正确注册在 `router.tsx` 中
- 使用 404 页面处理未知路由

**示例错误处理:**

```tsx
import { Alert } from 'antd';

const WebSocketDocPage: React.FC = () => {
  const [error, setError] = useState<string | null>(null);

  let markdownContent = '';
  try {
    markdownContent = require('@/../docs/websocket-usage.md?raw').default;
  } catch (err) {
    setError('文档加载失败，请刷新页面重试');
  }

  if (error) {
    return <Alert message={error} type="error" showIcon />;
  }

  return (
    <ReactMarkdown>{markdownContent}</ReactMarkdown>
  );
};
```

[Source: 前端最佳实践, docs/architecture/frontend-architecture.md]

---

### Performance Considerations

**文档页面性能优化:**

**1. Markdown 文件大小:**
- 预计文档大小 < 50KB，对性能影响微乎其微
- Vite 构建时会自动压缩和优化

**2. 代码高亮性能:**
- `react-syntax-highlighter` 支持按需加载语言定义
- 仅加载文档中使用的语言（JavaScript, JSON）
- 使用 `Prism` 而非 `Highlight.js`（更轻量）

**3. Lazy Loading（可选）:**
- 如果文档内容很多，可以考虑代码分割
- 使用 React `lazy()` 和 `Suspense` 延迟加载文档页面组件

**示例优化:**

```tsx
// 按需加载代码高亮样式
import { Prism as SyntaxHighlighter } from 'react-syntax-highlighter/dist/esm/light';
import javascript from 'react-syntax-highlighter/dist/esm/languages/prism/javascript';
import json from 'react-syntax-highlighter/dist/esm/languages/prism/json';

// 注册语言
SyntaxHighlighter.registerLanguage('javascript', javascript);
SyntaxHighlighter.registerLanguage('json', json);
```

[Source: 前端性能优化最佳实践]

---

## Change Log

| Date       | Version | Description             | Author             |
|------------|---------|-------------------------|--------------------|
| 2025-10-28 | 1.0     | 初始创建故事 3.8        | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used

claude-sonnet-4-5-20250929

### Debug Log References

无需 debug log

### Completion Notes List

1. **文档内容优化**: 根据用户反馈,将文档从"WebSocket 开发指南"重写为"平台使用指南",重点说明如何使用本平台而非如何开发 WebSocket 应用
2. **动态域名替换**: 实现了动态域名替换功能,文档中的 `wss://domain.com` 会自动替换为当前部署环境的实际域名
3. **侧边栏导航**: 添加了 Ant Design Anchor 组件实现的侧边栏大纲导航,支持锚点跳转和当前章节高亮
4. **代码高亮**: 未实现 `react-syntax-highlighter`,使用 CSS 样式实现了代码块的基础样式,满足 MVP 需求
5. **Task 6 (可选任务)**: 跳过,文档中已包含完整的浏览器和 Node.js 示例代码
6. **响应式设计**: 移动端(<992px)自动隐藏侧边栏导航,代码块支持横向滚动

### File List

**新建文件:**
- `docs/websocket-usage.md` - WebSocket 使用文档 (Markdown)
- `packages/frontend/src/pages/WebSocketDocPage.tsx` - 文档展示页面组件
- `packages/frontend/src/pages/WebSocketDocPage.css` - 文档页面样式

**修改文件:**
- `packages/frontend/src/router.tsx` - 添加文档页面路由
- `packages/frontend/src/pages/EndpointDetailPage.tsx` - 添加"查看使用文档"按钮
- `packages/frontend/package.json` - 添加依赖: react-markdown, remark-gfm

## QA Results

待 QA 代理填写
