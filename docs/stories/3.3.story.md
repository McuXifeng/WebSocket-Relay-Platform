# Story 3.3: 实现消息路由和广播逻辑

## Status

**Done**

## Story

**As a** 后端开发者,
**I want** 实现消息在同一端点多个客户端之间的广播转发,
**so that** 用户可以进行实时通信。

## Acceptance Criteria

1. 监听 WebSocket 的 `message` 事件:`socket.on('message', (data) => { ... })`
2. 解析接收到的消息(假设为 JSON 格式)
3. 根据发送者的 endpoint_id,查找该端点的所有连接(从 Map 中获取 Set)
4. 将消息广播给同一端点的所有其他客户端(不包括发送者本身)
5. 如果消息格式不是有效 JSON,记录警告日志但不中断连接
6. 实现广播函数:`broadcastToEndpoint(endpointId, message, senderSocket)`
7. 添加错误处理:如果某个客户端发送失败,记录日志但继续发送给其他客户端
8. 使用两个 `wscat` 客户端连接到同一 endpoint_id 进行测试
9. 验证:客户端 A 发送消息,客户端 B 能收到,但客户端 A 自己不收到(不回显)
10. 验证:客户端 B 发送消息,客户端 A 能收到

## Tasks / Subtasks

- [x] **Task 1: 在 WebSocket 服务器中实现 message 事件监听** (AC: 1, 2, 5)
  - [x] 在 `server.ts` 的连接处理函数中添加 `socket.on('message')` 监听器
  - [x] 解析接收到的消息数据:`const messageStr = data.toString()`
  - [x] 使用 try-catch 捕获 JSON 解析错误
  - [x] 如果解析失败,记录警告日志但不关闭连接:`console.warn('Invalid JSON message:', error)`
  - [x] 提取 socket 对象上的 `endpointId` 属性(已在 Story 3.2 中设置)

- [x] **Task 2: 创建消息广播函数** (AC: 3, 4, 6, 7)
  - [x] 在 `packages/backend/src/websocket/` 创建 `message-router.ts` 文件
  - [x] 实现 `broadcastToEndpoint(endpointId: string, message: any, senderSocket: WebSocket)` 函数
  - [x] 使用 `connectionManager.getConnections(endpointId)` 获取所有连接
  - [x] 遍历连接集合,排除发送者本身:`if (socket !== senderSocket)`
  - [x] 使用 try-catch 包裹每个 socket.send() 调用
  - [x] 如果发送失败,记录错误日志但继续发送给其他客户端
  - [x] 将消息序列化为 JSON 字符串再发送:`socket.send(JSON.stringify(message))`
  - [x] 导出 `broadcastToEndpoint` 函数供 `server.ts` 使用

- [x] **Task 3: 集成消息路由到 WebSocket 服务器** (AC: 6)
  - [x] 在 `server.ts` 中导入 `broadcastToEndpoint`:`import { broadcastToEndpoint } from './message-router'`
  - [x] 在 message 事件处理器中调用广播函数
  - [x] 传入正确的参数:`broadcastToEndpoint(endpointId, parsedMessage, socket)`
  - [x] 添加消息接收日志:`console.log(\`Message received from endpoint: \${endpointId}\`)`

- [x] **Task 4: 添加消息格式验证(可选增强)**
  - [x] 验证消息是否符合 `WebSocketMessage` 接口(包含 type 和 data 字段)
  - [x] 如果不符合,包装消息为标准格式:
    ```typescript
    {
      type: 'message',
      data: parsedMessage,
      timestamp: Date.now()
    }
    ```

- [x] **Task 5: 编写手动测试** (AC: 8, 9, 10)
  - [x] 启动 WebSocket 服务器:`pnpm --filter @websocket-relay/backend ws-server`
  - [x] 获取一个有效的 endpoint_id(使用 Prisma Studio 或数据库查询)
  - [x] 打开两个终端窗口,分别运行 wscat 连接到同一 endpoint_id
  - [x] 在客户端 A 中发送消息:`{ "type": "message", "data": "Hello from A" }`
  - [x] 验证客户端 B 收到消息,客户端 A 自己不回显
  - [x] 在客户端 B 中发送消息:`{ "type": "message", "data": "Hello from B" }`
  - [x] 验证客户端 A 收到消息
  - [x] 测试非 JSON 消息,验证服务器记录警告但不断开连接
  - [x] 测试多客户端(3 个或更多)广播,验证消息路由正确

- [x] **Task 6: 代码规范检查**
  - [x] 运行 `pnpm lint` 检查代码风格
  - [x] 运行 `pnpm format` 格式化代码
  - [x] 确保所有新文件符合 TypeScript 编码规范

## Dev Notes

### Previous Story Insights

**从 Story 3.2 中学到的关键经验:**

1. **ConnectionManager 已实现并可用**:
   - `ConnectionManager` 单例已在 `packages/backend/src/websocket/connection-manager.ts` 中创建
   - 提供 `getConnections(endpointId: string): Set<WebSocket>` 方法获取端点的所有连接
   - 每个 socket 对象已附加 `endpointId` 属性,可通过 `(socket as ExtendedWebSocket).endpointId` 访问

2. **ExtendedWebSocket 接口**:
   - 已定义 `ExtendedWebSocket` 接口扩展 WebSocket,包含 `endpointId` 和 `endpoint` 属性
   - 使用类型断言避免 TypeScript 错误:`const extSocket = socket as ExtendedWebSocket`

3. **错误处理模式**:
   - 使用标准的 SystemMessage 格式发送错误
   - WebSocket 关闭代码:1008(Policy Violation)用于格式错误,1011(Internal Error)用于服务器错误
   - 所有异步操作必须使用 try-catch 包裹

4. **测试工具**:
   - wscat 已安装并验证可用:`wscat -c "ws://localhost:3001/ws/{endpoint_id}"`
   - 可以创建自动化测试脚本(Node.js + ws 库)替代手动测试

[Previous Story: docs/stories/3.2.story.md]

---

### WebSocket Message Event Handling

**消息事件监听:**

根据 Node.js `ws` 库文档,WebSocket 的 `message` 事件处理器接收 `data` 参数:

```typescript
import { WebSocket } from 'ws';

socket.on('message', (data: Buffer | ArrayBuffer | Buffer[]) => {
  // data 可能是 Buffer、ArrayBuffer 或 Buffer[]
  // 通常使用 data.toString() 转换为字符串
  const messageStr = data.toString();

  try {
    const parsedMessage = JSON.parse(messageStr);
    // 处理消息...
  } catch (error) {
    console.warn('Invalid JSON message:', error);
    // 不关闭连接,记录警告即可
  }
});
```

**关键点:**

1. **数据类型转换**:data 参数通常为 Buffer 类型,使用 `data.toString()` 转换为字符串
2. **JSON 解析**:使用 `JSON.parse()` 解析消息,必须用 try-catch 包裹
3. **错误容忍**:如果消息格式不正确,记录警告但不断开连接(AC 5)

[Source: ws 库文档,Epic 3 Story 3.3 AC 1-2]

---

### Message Broadcasting Logic

**广播函数设计:**

根据 backend-architecture.md 中的 MessageRouter 组件说明,消息广播逻辑如下:

```typescript
// packages/backend/src/websocket/message-router.ts
import { WebSocket } from 'ws';
import { connectionManager } from './connection-manager';

export function broadcastToEndpoint(
  endpointId: string,
  message: any,
  senderSocket: WebSocket
): void {
  // 1. 获取该端点的所有连接
  const connections = connectionManager.getConnections(endpointId);

  // 2. 序列化消息
  const messageStr = JSON.stringify(message);

  // 3. 遍历所有连接,排除发送者
  connections.forEach((socket) => {
    if (socket !== senderSocket) {
      try {
        socket.send(messageStr);
      } catch (error) {
        console.error(`Failed to send message to client:`, error);
        // 继续发送给其他客户端,不中断
      }
    }
  });
}
```

**设计原则:**

1. **排除发送者**:使用 `if (socket !== senderSocket)` 确保不回显(AC 4)
2. **错误隔离**:每个 socket.send() 单独 try-catch,确保一个客户端失败不影响其他客户端(AC 7)
3. **消息序列化**:在循环外部统一序列化消息,避免重复 JSON.stringify()
4. **使用 ConnectionManager**:通过 `getConnections()` 获取连接集合,不直接访问 Map

[Source: docs/architecture/backend-architecture.md#MessageRouter, Epic 3 Story 3.3 AC 3-7]

---

### WebSocketMessage Type Definition

**消息格式标准:**

根据 data-models.md 定义的 `WebSocketMessage` 接口:

```typescript
// 客户端发送的消息格式
interface WebSocketMessage {
  type: 'message' | 'ping';
  data: any;
  timestamp: number;
}

// 服务器广播的消息格式(与客户端相同)
interface WebSocketBroadcast extends WebSocketMessage {
  type: 'message';
}
```

**消息验证和包装(可选增强):**

```typescript
function normalizeMessage(rawMessage: any): WebSocketBroadcast {
  // 如果消息已经符合标准格式,直接返回
  if (rawMessage.type && rawMessage.data !== undefined) {
    return {
      type: 'message',
      data: rawMessage.data,
      timestamp: rawMessage.timestamp || Date.now()
    };
  }

  // 否则包装为标准格式
  return {
    type: 'message',
    data: rawMessage,
    timestamp: Date.now()
  };
}
```

**使用场景:**

- **MVP 阶段**:可选,优先实现基本广播功能
- **生产环境**:推荐实现,确保消息格式一致性
- **客户端兼容性**:允许客户端发送简单格式消息(如 `"Hello"` 字符串),服务器自动包装

[Source: docs/architecture/data-models.md#WebSocketMessage]

---

### Error Handling for Message Broadcasting

**错误类型和处理策略:**

| 错误类型 | 场景 | 处理方式 | 示例 |
|---------|------|---------|------|
| JSON 解析错误 | 客户端发送非 JSON 数据 | 记录警告,不断开连接 | `console.warn('Invalid JSON:', error)` |
| socket.send() 失败 | 客户端连接已断开但未从 Map 移除 | 记录错误,继续广播给其他客户端 | `console.error('Send failed:', error)` |
| 空连接集合 | endpoint_id 无任何连接 | 正常情况,无需处理 | `connections.size === 0` |

**最佳实践:**

1. **不中断连接**:JSON 解析失败时,记录警告但继续保持连接(AC 5)
2. **错误隔离**:每个 socket.send() 单独 try-catch,确保一个失败不影响其他(AC 7)
3. **日志完整性**:记录足够的错误信息用于调试,但不暴露敏感信息
4. **优雅降级**:发送失败的客户端可能已断开,下次 close 事件会清理

**示例代码:**

```typescript
connections.forEach((socket) => {
  if (socket !== senderSocket) {
    try {
      socket.send(messageStr);
    } catch (error) {
      // 记录错误但不中断循环
      console.error(
        `Failed to send message to client in endpoint ${endpointId}:`,
        error instanceof Error ? error.message : error
      );
    }
  }
});
```

[Source: docs/architecture/coding-standards.md#Error Handling, AC 5, AC 7]

---

### Project Structure Alignment

**本故事需要创建/修改的文件:**

根据 unified-project-structure.md,文件路径如下:

```
packages/backend/src/websocket/
├── server.ts                 # 修改:添加 message 事件监听和广播调用
├── connection-manager.ts     # 已存在(Story 3.2 创建)
└── message-router.ts         # 新建:消息广播逻辑
```

**文件职责:**

- **`message-router.ts`**:封装消息广播逻辑,提供 `broadcastToEndpoint()` 函数
- **`server.ts`**:WebSocket 服务器主文件,监听 message 事件,调用 message-router

**导入路径:**

```typescript
// 在 server.ts 中导入
import { broadcastToEndpoint } from './message-router';
```

**代码组织原则:**

- **单一职责**:message-router 专注于消息路由,不处理连接管理
- **可测试性**:broadcastToEndpoint 是纯函数,易于单元测试
- **可扩展性**:未来可在 message-router 中添加消息过滤、转换等功能

[Source: docs/architecture/unified-project-structure.md]

---

### Integration with Existing Code

**已有的 WebSocket 服务器代码结构(Story 3.1 和 3.2):**

```typescript
// packages/backend/src/websocket/server.ts
import { WebSocket, WebSocketServer } from 'ws';
import { IncomingMessage } from 'http';
import { connectionManager } from './connection-manager';
import { PrismaClient } from '@prisma/client';

const wss = new WebSocketServer({ port: 3001 });
const prisma = new PrismaClient();

interface ExtendedWebSocket extends WebSocket {
  endpointId?: string;
  endpoint?: any;
}

wss.on('connection', async (socket: WebSocket, req: IncomingMessage) => {
  // Story 3.2 已实现:
  // 1. 解析 URL 中的 endpoint_id
  // 2. 验证 endpoint_id 在数据库中存在
  // 3. 调用 connectionManager.addConnection()
  // 4. 设置 socket.endpointId 和 socket.endpoint

  // Story 3.3 需要添加:
  socket.on('message', (data) => {
    // 消息处理逻辑
  });

  socket.on('close', () => {
    // Story 3.2 已实现:移除连接
  });
});
```

**集成步骤:**

1. **导入 message-router**:在文件顶部添加 `import { broadcastToEndpoint } from './message-router'`
2. **添加 message 监听器**:在 connection 事件处理器中添加 `socket.on('message')`
3. **访问 endpointId**:使用 `(socket as ExtendedWebSocket).endpointId` 获取端点 ID
4. **调用广播函数**:解析消息后调用 `broadcastToEndpoint(endpointId, message, socket)`

[Source: docs/stories/3.1.story.md, docs/stories/3.2.story.md]

---

### Testing Strategy

**测试方法:**

根据 testing-strategy.md,本故事优先使用**手动测试**,可选单元测试。

**手动测试步骤(AC 8-10):**

1. **启动 WebSocket 服务器:**
   ```bash
   pnpm --filter @websocket-relay/backend ws-server
   ```

2. **获取有效 endpoint_id:**
   - 使用 Prisma Studio:`npx prisma studio`
   - 或数据库查询:`SELECT endpoint_id FROM endpoints LIMIT 1`

3. **打开两个终端,分别连接到同一 endpoint_id:**
   ```bash
   # 终端 1 (客户端 A)
   wscat -c "ws://localhost:3001/ws/{valid_endpoint_id}"
   
   # 终端 2 (客户端 B)
   wscat -c "ws://localhost:3001/ws/{valid_endpoint_id}"
   ```

4. **测试客户端 A 发送消息:**
   - 在终端 1 中输入:`{"type": "message", "data": "Hello from A"}`
   - **预期结果**:
     - 终端 2(客户端 B)收到消息
     - 终端 1(客户端 A)自己不回显
     - 服务器打印:`Message received from endpoint: {endpoint_id}`

5. **测试客户端 B 发送消息:**
   - 在终端 2 中输入:`{"type": "message", "data": "Hello from B"}`
   - **预期结果**:
     - 终端 1(客户端 A)收到消息
     - 终端 2(客户端 B)自己不回显

6. **测试非 JSON 消息(AC 5):**
   - 在终端 1 中输入:`This is not JSON`
   - **预期结果**:
     - 服务器打印警告日志:`Invalid JSON message: ...`
     - 连接不断开,仍可继续发送其他消息

7. **测试多客户端广播:**
   - 打开第 3 个终端,连接到同一 endpoint_id
   - 从任一客户端发送消息
   - 验证其他两个客户端都收到消息,发送者自己不回显

**单元测试(可选):**

如果需要编写单元测试,参考 testing-strategy.md 中的 WebSocket 测试示例:

```typescript
// tests/websocket/message-routing.test.ts
import WebSocket from 'ws';

describe('WebSocket 消息路由', () => {
  it('应该在同一端点的客户端之间广播消息', async () => {
    const client1 = new WebSocket('ws://localhost:3001/ws/test-endpoint');
    const client2 = new WebSocket('ws://localhost:3001/ws/test-endpoint');

    await new Promise((resolve) => client1.on('open', resolve));
    await new Promise((resolve) => client2.on('open', resolve));

    const messagePromise = new Promise((resolve) => {
      client2.on('message', (data) => {
        const message = JSON.parse(data.toString());
        resolve(message);
      });
    });

    client1.send(JSON.stringify({ type: 'message', data: 'Hello' }));

    const receivedMessage = await messagePromise;
    expect(receivedMessage.data).toBe('Hello');

    client1.close();
    client2.close();
  });
});
```

[Source: docs/architecture/testing-strategy.md#WebSocket Tests, AC 8-10]

---

### Coding Standards Compliance

**TypeScript 命名规范:**

| Element | Convention | Example |
|---------|-----------|---------|
| 文件名 | kebab-case | `message-router.ts` |
| 函数名 | camelCase | `broadcastToEndpoint()` |
| 变量名 | camelCase | `messageStr`, `parsedMessage` |
| 接口名 | PascalCase | `ExtendedWebSocket` |

**导入规范:**

- 使用 ES6 导入语法:`import { broadcastToEndpoint } from './message-router'`
- 导入顺序:第三方库(ws, http) → 本地模块(connection-manager) → 类型定义

**错误处理:**

- 所有 JSON.parse() 使用 try-catch 包裹
- 所有 socket.send() 使用 try-catch 包裹
- 错误必须记录日志,不能静默失败

**代码检查:**

- 运行 `pnpm lint` 检查代码风格
- 运行 `pnpm format` 自动格式化代码
- 确保没有 ESLint 警告或错误

[Source: docs/architecture/coding-standards.md#Naming Conventions]

---

## Testing

### Test Organization

**本故事的测试策略:**

根据测试策略文档,本故事优先使用**手动测试**,单元测试为可选。

详细测试步骤和预期结果请参见 **Dev Notes > Testing Strategy** 部分。

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-28 | 1.0 | 初始创建故事 3.3 | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used

Claude Sonnet 4.5 (claude-sonnet-4-5-20250929)

### Debug Log References

无需调试日志，所有测试一次通过。

### Completion Notes List

- ✅ **消息路由功能完整实现**：在 `server.ts` 中添加了 message 事件监听器，支持 JSON 消息解析和错误处理
- ✅ **消息广播函数创建**：在 `message-router.ts` 中实现了 `broadcastToEndpoint()` 函数，正确排除发送者，支持错误隔离
- ✅ **消息格式标准化**：实现了 `normalizeMessage()` 函数，自动将任意格式消息转换为标准 WebSocketMessage 格式
- ✅ **TypeScript 类型安全**：使用 `unknown` 类型替代 `any`，正确处理 Buffer/ArrayBuffer/Buffer[] 类型
- ✅ **测试脚本创建**：创建了自动化测试脚本 `test-message-routing.mjs`，验证双向消息传递和无回显特性
- ✅ **代码规范检查**：通过 ESLint 检查，无错误，仅有少量不相关的警告

### File List

**新增文件：**
- `packages/backend/src/websocket/message-router.ts` - 消息路由和广播逻辑
- `packages/backend/test-message-routing.mjs` - 自动化测试脚本

**修改文件：**
- `packages/backend/src/websocket/server.ts` - 添加 message 事件监听和广播调用

## QA Results

待 QA 代理填写
