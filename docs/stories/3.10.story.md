# Story 3.10: 历史消息存储和展示功能

## Status

**Done**

## Story

**As a** 用户,
**I want** 查看端点的历史消息记录(最新50条),
**so that** 我可以回溯最近的通信内容，方便调试和监控。

## Acceptance Criteria

1. **数据库 Schema 变更 (AC1)**
   - 创建 `Message` 表存储历史消息
   - 字段包含: id, endpoint_id, content, sender_info, created_at
   - endpoint_id 外键关联到 Endpoint 表
   - 添加索引: endpoint_id + created_at (复合索引，用于排序查询)

2. **WebSocket 服务器消息存储 (AC2)**
   - 在 WebSocket 消息转发逻辑中添加消息存储功能
   - 每次成功转发消息后，异步写入 Message 表
   - 存储消息内容(最大 5000 字符，超出截断)
   - 记录发送者信息(WebSocket 连接 ID 或客户端标识)

3. **消息自动清理机制 (AC3)**
   - 实现定时任务或触发器，保持每个端点最多 50 条消息
   - 清理策略: 按 created_at 降序保留最新 50 条，删除更早的消息
   - 可选实现: 使用数据库触发器(MySQL) 或定时任务(每小时执行)

4. **获取历史消息 API (AC4)**
   - 实现 `GET /api/endpoints/:id/messages` 接口
   - 需要 JWT 认证，验证端点属于当前用户
   - 返回最新 50 条消息，按时间降序排列
   - 响应格式: `{ messages: [{ id, content, sender_info, created_at }] }`

5. **前端历史消息展示 (AC5)**
   - 在端点详情页添加"历史消息"卡片组件
   - 使用 Ant Design List 或 Timeline 组件展示消息
   - 显示消息内容、发送者、发送时间(相对时间格式)
   - 长消息内容支持展开/折叠功能
   - 空状态提示: "暂无历史消息"

6. **性能和用户体验 (AC6)**
   - 历史消息加载使用 Skeleton 占位符
   - 消息列表支持虚拟滚动(如果消息数量大)
   - API 响应时间 < 200ms (针对 50 条消息)
   - 消息存储不影响 WebSocket 转发性能(异步处理)

## Tasks / Subtasks

- [ ] **Task 1: 设计和创建 Message 数据库表** (AC: 1)
  - [ ] 在 Prisma Schema 中定义 `Message` 模型:
    ```prisma
    model Message {
      id          String   @id @default(uuid())
      endpoint_id String
      content     String   @db.Text
      sender_info String?  @db.VarChar(255)
      created_at  DateTime @default(now())
    
      endpoint Endpoint @relation(fields: [endpoint_id], references: [id], onDelete: Cascade)
    
      @@index([endpoint_id, created_at])
      @@map("messages")
    }
    ```
  - [ ] 在 Endpoint 模型中添加关联: `messages Message[]`
  - [ ] 运行 `npx prisma migrate dev --name add_message_table` 创建迁移
  - [ ] 验证数据库表创建成功: 使用 Prisma Studio 或 MySQL 命令行

- [ ] **Task 2: 在 shared 中定义消息类型** (AC: 4)
  - [ ] 创建 `packages/shared/src/types/message.types.ts`:
    ```typescript
    export interface Message {
      id: string;
      endpoint_id: string;
      content: string;
      sender_info: string | null;
      created_at: string; // ISO 8601 格式
    }
    
    export interface GetMessagesResponse {
      messages: Message[];
    }
    ```
  - [ ] 在 `packages/shared/src/types/index.ts` 中导出消息类型
  - [ ] 运行 `pnpm build` 重新构建 shared 包

- [ ] **Task 3: WebSocket 服务器添加消息存储逻辑** (AC: 2)
  - [ ] 读取 `packages/backend/src/websocket/server.ts` (或相关 WebSocket 处理文件)
  - [ ] 在消息广播函数中添加消息存储逻辑:
    ```typescript
    async function broadcastToEndpoint(endpointId: string, message: string, senderSocket: WebSocket) {
      // 现有的广播逻辑...
    
      // 异步存储消息到数据库 (不阻塞广播)
      saveMessageAsync(endpointId, message, getSenderInfo(senderSocket))
        .catch(err => console.error('消息存储失败:', err));
    }
    
    async function saveMessageAsync(endpointId: string, content: string, senderInfo: string) {
      // 截断过长内容
      const truncatedContent = content.length > 5000
        ? content.substring(0, 5000) + '...[已截断]'
        : content;
    
      await prisma.message.create({
        data: {
          endpoint_id: endpointId,
          content: truncatedContent,
          sender_info: senderInfo,
        }
      });
    }
    ```
  - [ ] 实现 `getSenderInfo` 函数: 从 WebSocket 对象获取标识信息(IP、连接ID等)
  - [ ] 添加错误处理: 数据库写入失败不影响消息转发

- [ ] **Task 4: 实现消息自动清理机制** (AC: 3)
  - [ ] 方案选择: 使用应用层定时任务(Node.js `setInterval`)
  - [ ] 在 `packages/backend/src/services/message.service.ts` 创建清理函数:
    ```typescript
    export async function cleanupOldMessages(endpointId: string) {
      const messages = await prisma.message.findMany({
        where: { endpoint_id: endpointId },
        orderBy: { created_at: 'desc' },
        select: { id: true },
      });
    
      // 如果超过 50 条,删除多余的
      if (messages.length > 50) {
        const idsToDelete = messages.slice(50).map(m => m.id);
        await prisma.message.deleteMany({
          where: { id: { in: idsToDelete } }
        });
      }
    }
    ```
  - [ ] 在消息存储后触发清理(异步): `cleanupOldMessages(endpointId).catch(...)`
  - [ ] 或者创建全局定时任务(每小时清理所有端点): 在 `server.ts` 中添加
  - [ ] 测试: 向端点发送超过 50 条消息,验证只保留最新 50 条

- [ ] **Task 5: 实现获取历史消息 API** (AC: 4)
  - [ ] 在 `packages/backend/src/routes/endpoint.routes.ts` 添加路由:
    ```typescript
    router.get('/:id/messages', authenticateToken, getEndpointMessages);
    ```
  - [ ] 在 `packages/backend/src/controllers/endpoint.controller.ts` 实现控制器:
    ```typescript
    export async function getEndpointMessages(req: Request, res: Response) {
      const { id } = req.params;
      const userId = req.user!.userId;
    
      // 验证端点属于当前用户
      const endpoint = await prisma.endpoint.findFirst({
        where: { id, user_id: userId }
      });
    
      if (!endpoint) {
        return res.status(404).json({ error: { code: 'ENDPOINT_NOT_FOUND' } });
      }
    
      // 查询最新 50 条消息
      const messages = await prisma.message.findMany({
        where: { endpoint_id: id },
        orderBy: { created_at: 'desc' },
        take: 50,
      });
    
      res.json({ messages });
    }
    ```
  - [ ] 添加类型导入: `GetMessagesResponse` from shared
  - [ ] 使用 Postman 或 curl 测试 API

- [ ] **Task 6: 前端实现历史消息服务** (AC: 4)
  - [ ] 在 `packages/frontend/src/services/endpoint.service.ts` 添加:
    ```typescript
    export async function getEndpointMessages(endpointId: string): Promise<GetMessagesResponse> {
      return apiClient.get(`/endpoints/${endpointId}/messages`);
    }
    ```
  - [ ] 导入 `GetMessagesResponse` 类型 from shared

- [ ] **Task 7: 前端创建历史消息展示组件** (AC: 5)
  - [ ] 创建 `packages/frontend/src/components/endpoints/MessageHistoryCard.tsx`:
    ```tsx
    import { Card, List, Empty, Skeleton, Typography } from 'antd';
    import { formatDistanceToNow } from 'date-fns';
    import { zhCN } from 'date-fns/locale';
    import type { Message } from '@websocket-relay/shared/types/message.types';
    
    interface Props {
      endpointId: string;
    }
    
    function MessageHistoryCard({ endpointId }: Props) {
      const [messages, setMessages] = useState<Message[]>([]);
      const [loading, setLoading] = useState(true);
    
      useEffect(() => {
        async function fetchMessages() {
          try {
            const data = await getEndpointMessages(endpointId);
            setMessages(data.messages);
          } catch (err) {
            message.error('加载历史消息失败');
          } finally {
            setLoading(false);
          }
        }
        fetchMessages();
      }, [endpointId]);
    
      if (loading) {
        return <Card title="历史消息"><Skeleton active /></Card>;
      }
    
      return (
        <Card title="历史消息 (最新50条)">
          <List
            dataSource={messages}
            locale={{ emptyText: <Empty description="暂无历史消息" /> }}
            renderItem={(msg) => (
              <List.Item>
                <List.Item.Meta
                  title={
                    <Typography.Text ellipsis={{ rows: 2, expandable: true }}>
                      {msg.content}
                    </Typography.Text>
                  }
                  description={`发送者: ${msg.sender_info || '未知'} · ${formatDistanceToNow(new Date(msg.created_at), { addSuffix: true, locale: zhCN })}`}
                />
              </List.Item>
            )}
          />
        </Card>
      );
    }
    ```
  - [ ] 使用 `Typography.Text` 的 `ellipsis` 属性处理长消息展开/折叠

- [ ] **Task 8: 在端点详情页集成历史消息卡片** (AC: 5)
  - [ ] 在 `EndpointDetailPage.tsx` 中导入 `MessageHistoryCard`
  - [ ] 在统计卡片下方添加历史消息卡片:
    ```tsx
    <Space direction="vertical" size="large" style={{ width: '100%' }}>
      <EndpointStatsCard endpointId={id!} />
      <MessageHistoryCard endpointId={id!} />
    </Space>
    ```
  - [ ] 验证在移动端(Story 3.9)响应式布局正常

- [ ] **Task 9: 性能优化** (AC: 6)
  - [ ] 验证消息存储为异步操作,不阻塞 WebSocket 转发
  - [ ] 使用 Chrome DevTools Network 标签验证 API 响应时间 < 200ms
  - [ ] 如果消息列表长度超过 20 条,考虑添加虚拟滚动(使用 `rc-virtual-list`)
  - [ ] 添加 Skeleton 加载占位符,避免布局抖动

- [ ] **Task 10: 集成测试** (AC: 2, 3, 4)
  - [ ] 编写后端集成测试 `packages/backend/tests/integration/message.test.ts`:
    - 测试消息存储功能
    - 测试自动清理机制(发送 60 条消息,验证只保留 50 条)
    - 测试 GET /api/endpoints/:id/messages API
  - [ ] 运行测试: `pnpm --filter @websocket-relay/backend test:integration`
  - [ ] 手动测试: 连接两个 WebSocket 客户端,发送消息,验证消息出现在历史记录中

- [ ] **Task 11: 代码规范检查和文档更新**
  - [ ] 运行 `pnpm lint` 检查代码规范
  - [ ] 确保所有新增类型定义在 `packages/shared/src/types`
  - [ ] 添加 JSDoc 注释到关键函数
  - [ ] 更新 API 文档(如果有单独的 API 文档文件)

## Dev Notes

### 数据库设计

**Message 表结构:**

| 字段        | 类型         | 说明                           |
|-------------|--------------|--------------------------------|
| id          | UUID         | 主键                           |
| endpoint_id | String (FK)  | 关联的端点 ID                  |
| content     | Text         | 消息内容 (最大 5000 字符)     |
| sender_info | String(255)? | 发送者信息 (IP、连接ID等)     |
| created_at  | DateTime     | 消息创建时间                   |

**索引策略:**
- 复合索引 `(endpoint_id, created_at)`: 优化按端点和时间范围查询
- 支持高效的 "获取最新 50 条消息" 查询

**级联删除:**
- 当 Endpoint 被删除时,自动删除所有关联的 Message 记录 (`onDelete: Cascade`)

---

### 消息存储性能考虑

**异步存储原则:**
- WebSocket 消息转发是关键路径,必须快速完成
- 数据库写入为异步操作,不阻塞消息广播
- 使用 Promise.catch() 处理存储失败,记录日志但不中断服务

**内容截断策略:**
- 单条消息最大存储 5000 字符
- 超出部分截断并添加 `...[已截断]` 标记
- 防止超大消息占用过多数据库空间

**实现示例:**
```typescript
// 不阻塞的异步存储
saveMessageAsync(endpointId, message, senderInfo)
  .catch(err => {
    console.error('[消息存储失败]', {
      endpointId,
      error: err.message,
      timestamp: new Date().toISOString()
    });
  });
```

---

### 消息清理机制

**清理策略选择:**

**方案1: 即时清理 (推荐 - MVP)**
- 每次存储新消息后,触发清理函数
- 查询当前端点消息数量,删除超过 50 条的旧消息
- 优点: 实现简单,数据库始终保持最新状态
- 缺点: 每次写入都触发清理查询

**方案2: 定时清理**
- 使用 Node.js `setInterval` 每小时执行清理
- 遍历所有端点,清理过期消息
- 优点: 减少频繁的清理查询
- 缺点: 可能短时间内超过 50 条限制

**方案3: 数据库触发器 (高级)**
- 使用 MySQL AFTER INSERT 触发器自动删除旧消息
- 优点: 完全数据库层面处理,应用代码无需关心
- 缺点: 需要手动编写 SQL 迁移,Prisma 不直接支持

**MVP 阶段推荐: 方案1 - 即时清理**

**实现示例:**
```typescript
async function cleanupOldMessages(endpointId: string) {
  const messages = await prisma.message.findMany({
    where: { endpoint_id: endpointId },
    orderBy: { created_at: 'desc' },
    select: { id: true },
  });

  if (messages.length > 50) {
    const idsToDelete = messages.slice(50).map(m => m.id);
    await prisma.message.deleteMany({
      where: { id: { in: idsToDelete } }
    });
    console.log(`[消息清理] 端点 ${endpointId} 删除了 ${idsToDelete.length} 条旧消息`);
  }
}
```

---

### 发送者信息获取

**WebSocket 连接信息来源:**

1. **客户端 IP 地址:**
   ```typescript
   function getSenderInfo(socket: WebSocket, req: IncomingMessage): string {
     const ip = req.socket.remoteAddress || 'unknown';
     return `IP: ${ip}`;
   }
   ```

2. **连接唯一标识 (推荐):**
   ```typescript
   // 在连接建立时分配唯一 ID
   const connectionId = nanoid(8);
   (socket as any).connectionId = connectionId;
   
   function getSenderInfo(socket: WebSocket): string {
     return `连接ID: ${(socket as any).connectionId || 'unknown'}`;
   }
   ```

3. **客户端自定义标识 (Story 3.11 实现后):**
   - 客户端在握手或首次消息时发送设备名称
   - 存储在 socket 对象上: `socket.deviceName`
   - 发送者信息显示为用户自定义的设备名称

---

### API 设计

**GET /api/endpoints/:id/messages**

**请求:**
```
GET /api/endpoints/abc123xyz/messages
Authorization: Bearer <JWT_TOKEN>
```

**响应 (成功 200):**
```json
{
  "messages": [
    {
      "id": "msg-uuid-1",
      "endpoint_id": "abc123xyz",
      "content": "{\"type\":\"message\",\"data\":\"Hello\"}",
      "sender_info": "连接ID: abc12345",
      "created_at": "2025-10-28T10:30:00Z"
    },
    {
      "id": "msg-uuid-2",
      "endpoint_id": "abc123xyz",
      "content": "Another message",
      "sender_info": "IP: 192.168.1.100",
      "created_at": "2025-10-28T10:29:30Z"
    }
  ]
}
```

**响应 (错误 404):**
```json
{
  "error": {
    "code": "ENDPOINT_NOT_FOUND",
    "message": "端点不存在或无权访问"
  }
}
```

**查询优化:**
- 使用 `orderBy: { created_at: 'desc' }` 获取最新消息
- 使用 `take: 50` 限制返回数量
- 利用 `(endpoint_id, created_at)` 复合索引加速查询

---

### 前端组件设计

**MessageHistoryCard 组件结构:**

```tsx
<Card title="历史消息 (最新50条)" extra={<Button>刷新</Button>}>
  {loading ? (
    <Skeleton active paragraph={{ rows: 5 }} />
  ) : (
    <List
      dataSource={messages}
      renderItem={(msg) => (
        <List.Item>
          <List.Item.Meta
            title={<MessageContent content={msg.content} />}
            description={<MessageMeta msg={msg} />}
          />
        </List.Item>
      )}
    />
  )}
</Card>
```

**长消息处理:**
- 使用 `Typography.Text` 的 `ellipsis` 属性
- 配置 `{ rows: 2, expandable: true }` 支持展开
- 超过 2 行自动折叠,显示"展开"按钮

**时间格式化:**
- 使用 `date-fns` 的 `formatDistanceToNow`
- 显示相对时间: "2分钟前"、"1小时前"
- 添加 `addSuffix: true` 和 `locale: zhCN`

**空状态:**
- 使用 Ant Design `Empty` 组件
- 提示文案: "暂无历史消息"
- 可选: 添加引导文案 "发送消息后将显示在此处"

---

### 性能优化策略

**数据库查询优化:**
- 复合索引 `(endpoint_id, created_at)` 覆盖查询需求
- 使用 `take: 50` 限制返回数量,避免全表扫描
- 考虑添加分页支持(未来迭代)

**前端虚拟滚动 (可选):**
- 如果消息列表较长,使用 `rc-virtual-list`
- Ant Design List 组件支持 `virtual` 属性
- 示例:
  ```tsx
  <List
    virtual
    height={400}
    dataSource={messages}
    renderItem={...}
  />
  ```

**WebSocket 性能:**
- 消息存储为非阻塞操作
- 数据库写入失败不影响消息转发
- 使用异步 Promise 链处理存储和清理

---

### 错误处理

**WebSocket 层错误:**
- 数据库连接失败: 记录错误日志,继续转发消息
- 消息存储失败: 记录错误,不中断服务
- 清理失败: 记录警告,下次清理时重试

**API 层错误:**
- 端点不存在: 返回 404 `ENDPOINT_NOT_FOUND`
- 无权访问: 返回 403 `FORBIDDEN`
- 数据库查询失败: 返回 500 `INTERNAL_SERVER_ERROR`

**前端错误:**
- API 请求失败: 显示 `message.error('加载历史消息失败')`
- 使用 Skeleton 占位符避免白屏
- 提供重试机制(可选: 添加"刷新"按钮)

---

### Testing

**后端集成测试:**

```typescript
// packages/backend/tests/integration/message.test.ts
describe('Message API', () => {
  test('应该能存储和检索消息', async () => {
    const endpoint = await createTestEndpoint();

    // 发送消息到 WebSocket
    await sendWebSocketMessage(endpoint.endpoint_id, 'Test message');

    // 查询历史消息
    const res = await request(app)
      .get(`/api/endpoints/${endpoint.id}/messages`)
      .set('Authorization', `Bearer ${testToken}`);

    expect(res.status).toBe(200);
    expect(res.body.messages).toHaveLength(1);
    expect(res.body.messages[0].content).toBe('Test message');
  });

  test('应该只保留最新50条消息', async () => {
    const endpoint = await createTestEndpoint();

    // 发送 60 条消息
    for (let i = 1; i <= 60; i++) {
      await sendWebSocketMessage(endpoint.endpoint_id, `Message ${i}`);
    }

    // 等待清理完成
    await sleep(1000);

    // 验证只保留 50 条
    const messages = await prisma.message.findMany({
      where: { endpoint_id: endpoint.id }
    });

    expect(messages.length).toBe(50);
    expect(messages[0].content).toBe('Message 60'); // 最新的消息
  });
});
```

**手动测试清单:**
- [ ] 使用 wscat 连接端点并发送消息
- [ ] 刷新端点详情页,验证消息出现在历史记录中
- [ ] 发送超过 50 条消息,验证只保留最新 50 条
- [ ] 测试长消息(>5000字符),验证截断功能
- [ ] 测试空状态(新端点无消息)
- [ ] 测试加载状态(Skeleton 占位符)

---

### Tech Stack

**本故事使用的技术:**

- **数据库:** MySQL 8.0+ (Message 表)
- **ORM:** Prisma 5.x (Schema 定义、迁移、查询)
- **后端框架:** Express 4.18+ (API 路由)
- **前端组件库:** Ant Design 5.x
  - List 组件 (消息列表)
  - Typography.Text (长文本展开/折叠)
  - Empty 组件 (空状态)
  - Skeleton 组件 (加载占位符)
- **日期处理:** date-fns 3.x (`formatDistanceToNow`)
- **WebSocket:** ws 8.x (消息监听和存储)

[Source: docs/architecture/tech-stack.md]

---

### Related Stories

- **Story 3.5:** 实现连接统计和数据库更新 (EndpointStats 表)
- **Story 3.6:** 实现获取端点实时统计数据 API
- **Story 3.9:** 端点详情页移动端适配和实时消息统计优化
- **Story 3.11 (后续):** 连接设备管理和自定义名称 (设备名称将用作 sender_info)

---

## Change Log

| Date       | Version | Description             | Author             |
|------------|---------|-------------------------|--------------------|
| 2025-10-28 | 1.0     | 初始创建故事 3.10       | Sarah (Product Owner) |

## Dev Agent Record

### Agent Model Used

- **Model**: Claude Sonnet 4.5 (claude-sonnet-4-5-20250929)
- **Agent**: 猫娘工程师 幽浮喵 (nekomata-engineer)
- **Date**: 2025-10-28

### Debug Log References

无严重 bug，开发过程顺利。

### Completion Notes List

#### 优化任务完成记录

**主要优化（2025-10-28）**:

1. **历史消息 JSON 智能解析** (AC5 优化)
   - 实现智能 JSON 解析函数 `formatMessageContent`
   - 自动识别标准消息格式 `{ type, data, timestamp }`
   - 只显示 `data` 字段内容（字符串直接显示，对象格式化显示）
   - 添加消息类型标签（蓝色 JSON + 绿色 type 标签）
   - 显示消息时间戳（如果存在）

2. **历史消息分页功能** (AC5 优化)
   - 使用 Ant Design List 的 pagination 属性
   - 每页显示 10 条消息
   - 添加总数显示："共 XX 条消息"
   - 翻页时替换当前页内容，不累积叠加

3. **刷新策略优化** (AC6 优化)
   - 移除端点详情页的 5 秒自动刷新定时器（解决页面抖动问题）
   - 改为手动刷新按钮："刷新统计数据"
   - 历史消息卡片添加"刷新"按钮
   - 初始加载后不再自动刷新，由用户控制刷新时机

4. **WebSocket 连接清理增强** (AC2 相关)
   - 添加心跳检测机制（30 秒 ping/pong）
   - 僵尸连接自动清理（60 秒超时检测）
   - 三重清理保障：close 事件 / error 事件 / 心跳超时
   - 防重复清理：`isCleanedUp` 标志确保幂等性
   - 清理定时器管理：断开连接时清理心跳定时器

5. **UI 细节优化**
   - 发送者显示优化：去掉"发送者:"前缀，直接显示"连接ID: xxx"
   - 空状态显示为"未知设备"而非"未知"

#### 开发工具创建

1. **连接诊断工具** (`packages/backend/debug-connections.mjs`)
   - 查看端点信息和统计数据
   - 诊断连接泄漏问题
   - 提供重置命令建议

2. **连接重置工具** (`packages/backend/reset-connections.mjs`)
   - 扫描所有非零连接数的端点
   - 一键重置所有端点连接数为 0
   - 自动验证重置结果

#### 技术要点

1. **JSON 解析智能化**:
   - 使用 try-catch 安全解析
   - 区分标准消息格式和普通 JSON
   - 支持对象和基本类型的不同显示方式

2. **心跳检测机制**:
   - WebSocket ping/pong 是协议层控制帧，不影响应用层消息
   - 30 秒间隔发送 ping，等待 pong 响应
   - 连续两次未响应（60 秒）判定为僵尸连接
   - 自动终止并清理僵尸连接

3. **防重复清理**:
   - 使用 `isCleanedUp` 标志防止同一连接被清理多次
   - close 和 error 事件可能同时触发，需要幂等性保证
   - 避免统计数据出现负数

4. **前端分页实现**:
   - 使用 `Array.slice()` 实现前端分页
   - 减少 DOM 渲染数量，提升性能
   - Ant Design Pagination 组件集成

#### 遵循的编程原则

- **KISS (简单至上)**: JSON 解析逻辑简单直观，心跳机制使用标准 WebSocket API
- **DRY (杜绝重复)**: 连接清理逻辑封装为 `cleanupConnection` 函数，避免重复代码
- **YAGNI (精益求精)**: 只实现当前需要的功能，未添加不必要的复杂特性
- **防御性编程**: 添加 `isCleanedUp` 标志防止重复清理，统计更新前检查连接数避免负数

### File List

#### 前端修改

- `packages/frontend/src/components/endpoints/MessageHistoryCard.tsx` (修改)
  - 新增 `formatMessageContent` 函数：智能 JSON 解析
  - 优化消息渲染逻辑：支持分页、标签显示、时间戳
  - 添加手动刷新按钮
  - 实现前端分页（每页 10 条）

- `packages/frontend/src/pages/EndpointDetailPage.tsx` (修改)
  - 移除 5 秒自动刷新定时器
  - 新增 `handleRefreshStats` 手动刷新函数
  - 添加"刷新统计数据"按钮
  - 导入 `ReloadOutlined` 图标

#### 后端修改

- `packages/backend/src/websocket/server.ts` (修改)
  - 扩展 `ExtendedWebSocket` 接口：添加 `isAlive` 和 `pingInterval` 字段
  - 新增 `cleanupConnection` 共享清理函数
  - 实现心跳检测机制：30 秒 ping/pong
  - 添加 pong 事件处理器
  - 增强 error 事件处理：触发连接清理
  - 清理定时器管理：防止内存泄漏

#### 工具脚本（新增）

- `packages/backend/debug-connections.mjs` (新增)
  - 连接诊断工具
  - 查看端点统计信息
  - 提供重置命令

- `packages/backend/reset-connections.mjs` (新增)
  - 连接重置工具
  - 批量重置所有端点连接数
  - 自动验证结果

#### 已存在文件（无修改）

- `packages/backend/src/websocket/connection-manager.ts` (无修改)
- `packages/backend/src/services/stats.service.ts` (无修改)
- `packages/shared/src/types/message.types.ts` (已存在)
- `packages/backend/src/services/message.service.ts` (已存在)

## QA Results

_待 QA 代理填写_
