# Story 3.4: 实现端点隔离机制

## Status

**Done**

## Story

**As a** 后端开发者,
**I want** 确保不同端点的消息完全隔离,
**so that** 用户的消息不会泄露到其他端点。

## Acceptance Criteria

1. 使用测试脚本创建两个不同的 endpoint(endpoint_A 和 endpoint_B)
2. 启动 4 个 WebSocket 客户端:
   - 客户端 1 和 2 连接到 endpoint_A
   - 客户端 3 和 4 连接到 endpoint_B
3. 客户端 1 发送消息 "Hello from A"
4. 验证:客户端 2 能收到消息,客户端 3 和 4 收不到
5. 客户端 3 发送消息 "Hello from B"
6. 验证:客户端 4 能收到消息,客户端 1 和 2 收不到
7. 检查 Map 数据结构,确认两个 endpoint_id 分别管理各自的 Set<WebSocket>
8. 编写自动化测试脚本(使用 Node.js ws 客户端库),验证隔离机制

## Tasks / Subtasks

- [x] **Task 1: 创建测试端点准备脚本** (AC: 1)
  - [x] 在 `packages/backend/` 创建 `test-endpoint-isolation.mjs` 脚本
  - [x] 使用 Prisma Client 查询或创建两个测试端点(endpoint_A 和 endpoint_B)
  - [x] 如果端点不存在,使用已注册的测试用户创建端点
  - [x] 打印两个端点的 `endpoint_id`,用于后续 WebSocket 连接
  - [x] 脚本可独立运行:`node test-endpoint-isolation.mjs`

- [x] **Task 2: 编写 WebSocket 客户端隔离测试逻辑** (AC: 2, 3, 4, 5, 6)
  - [x] 在测试脚本中使用 `ws` 库创建 4 个 WebSocket 客户端
  - [x] 客户端 1 和 2 连接到 `ws://localhost:3001/ws/{endpoint_A_id}`
  - [x] 客户端 3 和 4 连接到 `ws://localhost:3001/ws/{endpoint_B_id}`
  - [x] 等待所有客户端连接成功(监听 `open` 事件)
  - [x] **测试场景 1:**
    - 客户端 1 发送消息:`{ "type": "message", "data": "Hello from A" }`
    - 客户端 2 监听消息,验证收到 "Hello from A"
    - 客户端 3 和 4 设置超时监听器(500ms),验证没有收到任何消息
  - [x] **测试场景 2:**
    - 客户端 3 发送消息:`{ "type": "message", "data": "Hello from B" }`
    - 客户端 4 监听消息,验证收到 "Hello from B"
    - 客户端 1 和 2 设置超时监听器(500ms),验证没有收到任何消息
  - [x] 使用 Promise 和 async/await 编写清晰的测试流程
  - [x] 测试完成后关闭所有客户端连接

- [x] **Task 3: 验证 ConnectionManager 的端点隔离机制** (AC: 7)
  - [x] 在测试脚本中添加日志输出,显示当前连接的端点分布
  - [x] 验证 ConnectionManager 的 Map 数据结构正确维护两个独立的 Set
  - [x] (可选)添加调试代码,打印 `connectionManager.getConnections(endpoint_A_id).size` 和 `connectionManager.getConnections(endpoint_B_id).size`
  - [x] 确认两个端点的连接集合完全独立,互不干扰

- [x] **Task 4: 测试执行和结果验证** (AC: 8)
  - [x] 启动 WebSocket 服务器:`pnpm --filter @websocket-relay/backend ws-server`
  - [x] 运行测试脚本:`node test-endpoint-isolation.mjs`
  - [x] 验证测试脚本输出:
    - ✓ 4 个客户端成功连接
    - ✓ 客户端 1 发送消息,客户端 2 收到,客户端 3 和 4 未收到
    - ✓ 客户端 3 发送消息,客户端 4 收到,客户端 1 和 2 未收到
    - ✓ 端点隔离验证通过
  - [x] 如果测试失败,检查 ConnectionManager 逻辑和消息路由代码

- [x] **Task 5: 代码规范检查**
  - [x] 运行 `pnpm lint` 检查代码风格
  - [x] 运行 `pnpm format` 格式化代码
  - [x] 确保测试脚本遵循 TypeScript/ESM 规范

## Dev Notes

### Previous Story Insights

**从 Story 3.3 中学到的关键经验:**

1. **ConnectionManager 架构已实现**:
   - `ConnectionManager` 单例维护 `Map<endpoint_id, Set<WebSocket>>`
   - `getConnections(endpointId)` 方法返回指定端点的所有连接
   - 连接隔离是通过 Map 的键(endpoint_id)自然实现的

2. **消息广播逻辑**:
   - `broadcastToEndpoint()` 函数只查找指定 endpoint_id 的连接集合
   - 消息不会跨端点传播,因为每个端点的连接存储在独立的 Set 中

3. **WebSocket 测试工具**:
   - 使用 `ws` 库创建客户端:`new WebSocket('ws://localhost:3001/ws/{endpoint_id}')`
   - 监听 `open` 事件确认连接成功
   - 监听 `message` 事件接收服务器消息
   - 使用 `socket.send()` 发送 JSON 消息

4. **ExtendedWebSocket 接口**:
   - 每个 socket 对象附加了 `endpointId` 属性
   - 在消息处理器中可通过 `(socket as ExtendedWebSocket).endpointId` 访问

[Previous Story: docs/stories/3.3.story.md]

---

### ConnectionManager Architecture

**连接池隔离机制:**

根据 backend-architecture.md 和 Story 3.2 的实现,ConnectionManager 使用以下数据结构:

```typescript
// packages/backend/src/websocket/connection-manager.ts
class ConnectionManager {
  private connections: Map<string, Set<WebSocket>>;

  addConnection(endpointId: string, socket: WebSocket): void {
    if (!this.connections.has(endpointId)) {
      this.connections.set(endpointId, new Set());
    }
    this.connections.get(endpointId)!.add(socket);
  }

  getConnections(endpointId: string): Set<WebSocket> {
    return this.connections.get(endpointId) || new Set();
  }

  removeConnection(endpointId: string, socket: WebSocket): void {
    const connections = this.connections.get(endpointId);
    if (connections) {
      connections.delete(socket);
      if (connections.size === 0) {
        this.connections.delete(endpointId);
      }
    }
  }
}
```

**隔离保证:**

1. **键值隔离**:每个 endpoint_id 作为 Map 的唯一键,不同端点的连接存储在不同的 Set 中
2. **查询隔离**:`getConnections(endpointId)` 只返回指定端点的连接,不会访问其他端点
3. **广播隔离**:`broadcastToEndpoint()` 只遍历当前端点的连接 Set,消息不会泄露

[Source: docs/architecture/backend-architecture.md#WebSocket Server, docs/stories/3.2.story.md]

---

### Message Routing Verification

**消息路由逻辑(Story 3.3 已实现):**

```typescript
// packages/backend/src/websocket/message-router.ts
export function broadcastToEndpoint(
  endpointId: string,
  message: unknown,
  senderSocket: WebSocket
): void {
  // 1. 获取该端点的所有连接(仅限当前端点)
  const connections = connectionManager.getConnections(endpointId);

  // 2. 遍历连接并广播(排除发送者)
  connections.forEach((socket) => {
    if (socket !== senderSocket) {
      try {
        socket.send(JSON.stringify(message));
      } catch (error) {
        console.error(`Failed to send message to client:`, error);
      }
    }
  });
}
```

**隔离验证点:**

- `getConnections(endpointId)` 确保只获取当前端点的连接
- 不同 endpoint_id 调用 `broadcastToEndpoint()` 会操作完全独立的连接集合
- 消息不可能发送到其他端点的客户端

[Source: docs/stories/3.3.story.md#Dev Notes > Message Broadcasting Logic]

---

### WebSocket Client Testing Pattern

**测试脚本架构(使用 ws 库):**

根据 testing-strategy.md,WebSocket 测试推荐使用 Node.js `ws` 客户端库:

```typescript
// test-endpoint-isolation.mjs
import WebSocket from 'ws';

async function testEndpointIsolation() {
  // 创建 4 个客户端
  const clientA1 = new WebSocket('ws://localhost:3001/ws/endpoint_A_id');
  const clientA2 = new WebSocket('ws://localhost:3001/ws/endpoint_A_id');
  const clientB1 = new WebSocket('ws://localhost:3001/ws/endpoint_B_id');
  const clientB2 = new WebSocket('ws://localhost:3001/ws/endpoint_B_id');

  // 等待所有连接建立
  await Promise.all([
    waitForOpen(clientA1),
    waitForOpen(clientA2),
    waitForOpen(clientB1),
    waitForOpen(clientB2)
  ]);

  // 测试场景 1:endpoint_A 内部广播,endpoint_B 不受影响
  const testA = new Promise((resolve) => {
    let receivedA2 = false;
    let receivedB1 = false;
    let receivedB2 = false;

    clientA2.on('message', (data) => {
      const msg = JSON.parse(data.toString());
      if (msg.data === 'Hello from A') receivedA2 = true;
    });

    clientB1.on('message', () => { receivedB1 = true; });
    clientB2.on('message', () => { receivedB2 = true; });

    clientA1.send(JSON.stringify({ type: 'message', data: 'Hello from A' }));

    // 500ms 后验证结果
    setTimeout(() => {
      resolve({ receivedA2, receivedB1, receivedB2 });
    }, 500);
  });

  const resultA = await testA;
  console.log('Endpoint A isolation test:', resultA);
  // 预期:{ receivedA2: true, receivedB1: false, receivedB2: false }

  // 测试场景 2:endpoint_B 内部广播,endpoint_A 不受影响
  // 类似逻辑...

  // 关闭所有连接
  [clientA1, clientA2, clientB1, clientB2].forEach(c => c.close());
}

function waitForOpen(ws) {
  return new Promise((resolve) => ws.on('open', resolve));
}
```

**关键测试要点:**

1. **异步等待**:使用 Promise 等待所有连接建立
2. **超时验证**:通过 setTimeout 验证"未收到消息"的场景
3. **布尔标记**:使用布尔变量跟踪消息接收情况
4. **清理资源**:测试完成后关闭所有连接

[Source: docs/architecture/testing-strategy.md#WebSocket Tests]

---

### Endpoint Creation for Testing

**测试端点准备:**

在测试脚本中,需要确保两个测试端点存在。使用 Prisma Client 查询或创建端点:

```typescript
import { PrismaClient } from '@prisma/client';
import { nanoid } from 'nanoid';

const prisma = new PrismaClient();

async function ensureTestEndpoints() {
  // 查询或创建测试用户(假设存在 username='admin' 的用户)
  const testUser = await prisma.user.findUnique({
    where: { username: 'admin' }
  });

  if (!testUser) {
    throw new Error('Test user not found. Please create an admin user first.');
  }

  // 创建或获取 endpoint_A
  let endpointA = await prisma.endpoint.findFirst({
    where: { name: 'Test Endpoint A', user_id: testUser.id }
  });

  if (!endpointA) {
    endpointA = await prisma.endpoint.create({
      data: {
        endpoint_id: nanoid(10),
        name: 'Test Endpoint A',
        user_id: testUser.id
      }
    });
  }

  // 创建或获取 endpoint_B
  let endpointB = await prisma.endpoint.findFirst({
    where: { name: 'Test Endpoint B', user_id: testUser.id }
  });

  if (!endpointB) {
    endpointB = await prisma.endpoint.create({
      data: {
        endpoint_id: nanoid(10),
        name: 'Test Endpoint B',
        user_id: testUser.id
      }
    });
  }

  console.log('Test endpoints ready:');
  console.log('- Endpoint A:', endpointA.endpoint_id);
  console.log('- Endpoint B:', endpointB.endpoint_id);

  return { endpointA, endpointB };
}
```

**注意事项:**

- 使用 `nanoid` 生成 endpoint_id(与生产环境一致)
- 测试端点关联到已存在的用户(如 admin)
- 如果端点已存在,直接复用,避免重复创建
- 脚本需要在 `packages/backend/.env` 配置正确的 `DATABASE_URL`

[Source: docs/architecture/data-models.md#Endpoint, docs/architecture/tech-stack.md#ID Generation]

---

### Project Structure Alignment

**本故事需要创建的文件:**

根据 unified-project-structure.md,测试脚本位置:

```
packages/backend/
├── src/
│   └── websocket/
│       ├── server.ts               # 已存在(Story 3.1)
│       ├── connection-manager.ts   # 已存在(Story 3.2)
│       └── message-router.ts       # 已存在(Story 3.3)
└── test-endpoint-isolation.mjs     # 新建:端点隔离测试脚本
```

**文件职责:**

- **`test-endpoint-isolation.mjs`**:独立的测试脚本,验证端点隔离机制
  - 创建/获取测试端点
  - 启动 4 个 WebSocket 客户端
  - 执行隔离测试场景
  - 输出测试结果

**命名规范:**

- 使用 `.mjs` 扩展名支持 ES Modules(与 `ws` 库兼容)
- 使用 `test-` 前缀标识测试文件
- 使用 kebab-case 命名:`test-endpoint-isolation.mjs`

[Source: docs/architecture/unified-project-structure.md, docs/architecture/coding-standards.md#Naming Conventions]

---

### Testing Requirements

**测试策略(本故事重点):**

根据 testing-strategy.md,WebSocket 功能需要编写专门的集成测试:

**测试类型:WebSocket Integration Test**

- **目标**:验证端点隔离机制在真实 WebSocket 服务器环境中的正确性
- **工具**:`ws` 库(Node.js WebSocket 客户端)
- **方法**:创建多客户端连接,发送消息,验证接收情况
- **验证点**:
  1. 同端点客户端能互相收到消息
  2. 不同端点客户端完全隔离,不会收到对方消息
  3. ConnectionManager 的 Map 数据结构正确维护端点连接

**测试执行步骤:**

1. 启动 WebSocket 服务器(手动或通过 npm script)
2. 运行测试脚本:`node test-endpoint-isolation.mjs`
3. 验证测试输出:所有隔离验证通过
4. 测试完成后自动清理资源(关闭连接)

**成功标准:**

- ✓ 客户端 A1 发送消息,A2 收到,B1 和 B2 未收到
- ✓ 客户端 B1 发送消息,B2 收到,A1 和 A2 未收到
- ✓ 无错误日志,无异常连接断开
- ✓ 测试脚本输出明确的"通过"标识

[Source: docs/architecture/testing-strategy.md#WebSocket Tests]

---

### Error Handling and Edge Cases

**潜在边缘情况:**

1. **端点不存在**:
   - 测试脚本应先创建或验证端点存在
   - 如果端点不存在,WebSocket 连接会被拒绝(Story 3.2 已实现)

2. **连接超时**:
   - 使用 Promise.race() 设置连接超时(5秒)
   - 超时则抛出错误,提示 WebSocket 服务器未启动

3. **消息接收超时**:
   - 使用 setTimeout 验证"未收到消息"的场景
   - 500ms 足够检测消息是否泄露到其他端点

4. **资源清理**:
   - 测试结束后关闭所有 WebSocket 连接
   - 使用 `prisma.$disconnect()` 关闭数据库连接

**错误处理代码示例:**

```typescript
try {
  await testEndpointIsolation();
  console.log('✓ All isolation tests passed!');
} catch (error) {
  console.error('✗ Test failed:', error.message);
  process.exit(1);
} finally {
  await prisma.$disconnect();
}
```

[Source: docs/architecture/coding-standards.md#Error Handling]

---

## Testing

### Test Organization

**本故事的测试策略:**

本故事的核心就是编写测试脚本验证端点隔离机制。测试脚本本身即是交付物。

**测试文件:**

- `packages/backend/test-endpoint-isolation.mjs` - WebSocket 端点隔离集成测试

**测试执行:**

```bash
# 1. 启动 WebSocket 服务器
pnpm --filter @websocket-relay/backend ws-server

# 2. 运行隔离测试脚本
node packages/backend/test-endpoint-isolation.mjs
```

**预期输出:**

```
Test endpoints ready:
- Endpoint A: abc123xyz
- Endpoint B: def456uvw

Connecting 4 WebSocket clients...
✓ All clients connected

Testing Endpoint A isolation...
✓ Client A2 received message from A1
✓ Client B1 did not receive message (isolated)
✓ Client B2 did not receive message (isolated)

Testing Endpoint B isolation...
✓ Client B2 received message from B1
✓ Client A1 did not receive message (isolated)
✓ Client A2 did not receive message (isolated)

✓ All isolation tests passed!
```

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-28 | 1.0 | 初始创建故事 3.4 | Bob (Scrum Master) |
| 2025-10-28 | 1.1 | 完成端点隔离测试脚本实现,所有测试通过 | James (Dev Agent) |

## Dev Agent Record

### Agent Model Used

- Model: Claude Sonnet 4.5 (claude-sonnet-4-5-20250929)
- Agent: James (Full Stack Developer)
- Date: 2025-10-28

### Debug Log References

无调试问题,测试一次性通过。

### Completion Notes List

1. **测试脚本实现**: 创建了完整的端点隔离测试脚本 `test-endpoint-isolation.mjs`,包含端点准备、4 个 WebSocket 客户端连接、双向隔离测试验证
2. **测试结果**: 所有测试场景通过,验证了 ConnectionManager 的端点隔离机制正常工作
3. **关键发现**: 需要在客户端连接建立后等待 500ms 再发送消息,确保连接完全就绪
4. **代码质量**: 通过 ESLint 和 Prettier 检查,遵循项目编码规范

### File List

**新增文件:**
- `packages/backend/test-endpoint-isolation.mjs` - 端点隔离测试脚本

**无修改文件** (现有的 ConnectionManager 和 MessageRouter 实现已经正确支持端点隔离)

## QA Results

待 QA 代理填写
