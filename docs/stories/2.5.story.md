# Story 2.5: 实现端点管理主页前端（列表展示）

## Status

**Done**

## Story

**As a** 用户，
**I want** 在端点管理主页查看我的所有端点列表，
**so that** 我可以了解我创建了哪些端点。

## Acceptance Criteria

1. 创建端点管理主页组件 `/dashboard`，使用 Ant Design Layout
2. 页面加载时调用 `GET /api/endpoints` 获取端点列表
3. 使用 Ant Design Table 或 List 组件展示端点列表
4. 每个端点显示:端点名称、WebSocket URL、创建时间、最后活跃时间
5. WebSocket URL 旁边显示"复制"按钮(使用 Ant Design Button + CopyOutlined 图标)
6. 如果列表为空,显示 Empty 组件提示"还没有端点,点击创建按钮开始"
7. 页面顶部显示用户欢迎信息(如"欢迎,{username}")和"创建端点"按钮
8. 加载数据时显示 Spin 加载动画
9. 如果 API 请求失败,显示 `message.error()` 错误提示

## Tasks / Subtasks

- [x] **Task 1: 创建端点 API Service 函数** (AC: 2, 9)
  - [x] 在 `packages/frontend/src/services/endpoint.service.ts` 中创建 `getEndpoints()` 函数
  - [x] 使用 Axios 调用 `GET /api/endpoints` API
  - [x] 函数返回类型为 `Promise<EndpointWithUrl[]>`
  - [x] 包含错误处理逻辑,抛出 API 错误信息
  - [x] 参考 `packages/shared/src/types/endpoint.types.ts` 中的类型定义

- [x] **Task 2: 创建 Dashboard 页面组件** (AC: 1, 7)
  - [x] 在 `packages/frontend/src/pages/DashboardPage.tsx` 中创建主页面组件
  - [x] 使用 Ant Design `Layout` 组件构建页面结构
  - [x] 添加页面头部:显示欢迎信息"欢迎,{username}"
  - [x] 从 `AuthContext` 获取当前用户信息 (`useAuth()` hook)
  - [x] 添加"创建端点"按钮(Button type="primary"),暂时不实现点击逻辑
  - [x] 设置组件基础布局和样式

- [x] **Task 3: 实现端点列表数据加载** (AC: 2, 8)
  - [x] 使用 `useState` 管理端点列表状态: `endpoints`, `loading`, `error`
  - [x] 使用 `useEffect` 在组件挂载时调用 `getEndpoints()` API
  - [x] 加载过程中设置 `loading = true`,显示 Spin 组件
  - [x] 成功后更新 `endpoints` 状态并设置 `loading = false`
  - [x] 失败时设置 `error` 状态并使用 `message.error()` 显示错误信息

- [x] **Task 4: 使用 Ant Design Table 组件展示端点列表** (AC: 3, 4, 5, 6)
  - [x] 使用 `Table` 组件,设置 `dataSource={endpoints}` 和 `loading={loading}`
  - [x] 定义 Table columns 配置:
    - `name` 列:显示端点名称
    - `websocket_url` 列:显示 WebSocket URL 并添加"复制"按钮(CopyOutlined 图标)
    - `created_at` 列:格式化显示创建时间(使用 date-fns 格式化)
    - `last_active_at` 列:格式化显示最后活跃时间(nullable)
  - [x] 实现"复制"按钮点击功能:
    - 使用 `navigator.clipboard.writeText()` 复制 URL
    - 成功后显示 `message.success('已复制')`
  - [x] 为 Table 设置 `locale` 属性,自定义空数据提示为"还没有端点,点击创建按钮开始"
  - [x] 设置 `rowKey="id"` 使用端点 ID 作为唯一标识

- [x] **Task 5: 添加路由配置** (AC: 1)
  - [x] 在 `packages/frontend/src/router.tsx` 中添加 `/dashboard` 路由
  - [x] 配置为受保护路由,使用 `<ProtectedRoute>` 包裹
  - [x] 绑定到 `DashboardPage` 组件
  - [x] 设置为登录后默认跳转页面(如需要,更新登录成功跳转逻辑)

- [x] **Task 6: 代码规范检查和测试**
  - [x] 运行 `pnpm lint` 检查代码风格
  - [x] 运行 `pnpm format` 格式化代码
  - [x] 手动测试页面加载、列表显示、复制功能
  - [x] 测试空列表场景和错误场景

## Dev Notes

### Previous Story Insights

**从 Story 2.4 中学到的重要经验:**

1. **后端 API 已就绪**: Story 2.3 已实现 `GET /api/endpoints` API,返回当前用户的端点列表,按创建时间倒序排列
2. **Endpoint 类型定义**: `packages/shared/src/types/endpoint.types.ts` 中已定义 `EndpointWithUrl` 类型,包含 `websocket_url` 字段
3. **API 响应格式**: 后端统一使用 `{ data: { endpoints: [...] } }` 响应格式
4. **JWT 认证**: API 需要在 Header 中携带 `Authorization: Bearer {token}`,前端 Axios 拦截器应已配置自动附加
5. **错误处理模式**: 后端返回标准错误格式 `{ error: { code, message, timestamp, requestId } }`

[Previous Story: docs/stories/2.4.story.md]

### Frontend Architecture Context

**React 组件组织结构**:

根据前端架构文档,项目使用以下目录结构:

```
packages/frontend/src/
├── pages/               # 页面组件
│   └── DashboardPage.tsx  # 本故事创建的主页面
├── services/            # API 调用服务
│   └── endpoint.service.ts  # 本故事创建的端点 API Service
├── contexts/            # React Context
│   └── AuthContext.tsx  # 已存在,用于获取用户信息
├── hooks/               # 自定义 Hooks
│   └── useAuth.ts  # 已存在,从 AuthContext 获取用户状态
└── router.tsx          # 路由配置,本故事需添加 /dashboard 路由
```

**关键架构原则**:

- **API Calls**: 前端永远通过 `services/` 层调用 API,禁止直接使用 Axios [Source: docs/architecture/coding-standards.md#Critical Fullstack Rules]
- **State Management**: 使用 React Context API 管理全局用户认证状态,组件状态使用 useState [Source: docs/architecture/frontend-architecture.md#State Management]
- **Routing**: 使用 `<ProtectedRoute>` 保护需要登录的页面 [Source: docs/architecture/frontend-architecture.md#Routing]

### API Endpoint Specification

**GET /api/endpoints API 规范**:

根据 REST API 规范,端点列表查询 API 属于 `/api/endpoints/*` 端点组。

**请求格式**:

```http
GET /api/endpoints
Authorization: Bearer {JWT_TOKEN}
```

**成功响应 (200 OK)**:

```json
{
  "data": {
    "endpoints": [
      {
        "id": "uuid-string",
        "endpoint_id": "abc123xyz",
        "name": "我的端点",
        "websocket_url": "wss://domain.com/ws/abc123xyz",
        "created_at": "2025-10-28T10:00:00.000Z",
        "last_active_at": "2025-10-28T12:30:00.000Z"
      },
      ...
    ]
  }
}
```

**空列表响应**:

```json
{
  "data": {
    "endpoints": []
  }
}
```

**错误响应 (401 - 未认证)**:

```json
{
  "error": {
    "code": "UNAUTHORIZED",
    "message": "未授权",
    "timestamp": "2025-10-28T10:00:00.000Z",
    "requestId": "uuid"
  }
}
```

[Source: docs/architecture/api-specification.md#REST API Overview, Story 2.3 实现]

### Data Models: Endpoint

**Endpoint 数据模型详细说明**:

根据数据模型文档,前端展示端点列表需要使用 `EndpointWithUrl` 类型。

**TypeScript 接口定义(已存在于 `packages/shared/src/types/endpoint.types.ts`)**:

```typescript
interface Endpoint {
  id: string;
  endpoint_id: string;
  name: string;
  user_id: string;
  created_at: Date;
  last_active_at: Date | null;
}

// 前端展示用扩展类型(包含 WebSocket URL)
interface EndpointWithUrl extends Endpoint {
  websocket_url: string;    // 格式: wss://domain.com/ws/{endpoint_id}
}
```

**字段说明**:

- `id`: 数据库主键(UUID),用于 Table 的 rowKey
- `endpoint_id`: 短 ID,用于 WebSocket URL 路径
- `name`: 用户自定义端点名称,显示在列表中
- `websocket_url`: 完整的 WebSocket 连接 URL,需要提供复制功能
- `created_at`: 创建时间,需要格式化显示(例如: "2025-10-28 10:30")
- `last_active_at`: 最后活跃时间,可能为 null,需要处理空值显示(例如: "从未活跃")

[Source: docs/architecture/data-models.md#Endpoint]

### Ant Design Component Usage

**Table 组件配置**:

根据 Ant Design 5.x 文档,Table 组件的基本用法:

```typescript
import { Table, Button, message } from 'antd';
import { CopyOutlined } from '@ant-design/icons';
import type { ColumnsType } from 'antd/es/table';

const columns: ColumnsType<EndpointWithUrl> = [
  {
    title: '端点名称',
    dataIndex: 'name',
    key: 'name',
  },
  {
    title: 'WebSocket URL',
    dataIndex: 'websocket_url',
    key: 'websocket_url',
    render: (url: string) => (
      <>
        <span style={{ marginRight: 8 }}>{url}</span>
        <Button
          size="small"
          icon={<CopyOutlined />}
          onClick={() => handleCopy(url)}
        >
          复制
        </Button>
      </>
    ),
  },
  {
    title: '创建时间',
    dataIndex: 'created_at',
    key: 'created_at',
    render: (date: string) => format(new Date(date), 'yyyy-MM-dd HH:mm'),
  },
  {
    title: '最后活跃时间',
    dataIndex: 'last_active_at',
    key: 'last_active_at',
    render: (date: string | null) =>
      date ? format(new Date(date), 'yyyy-MM-dd HH:mm') : '从未活跃',
  },
];

<Table
  dataSource={endpoints}
  columns={columns}
  rowKey="id"
  loading={loading}
  locale={{
    emptyText: '还没有端点,点击创建按钮开始'
  }}
/>
```

**Layout 组件配置**:

```typescript
import { Layout } from 'antd';

const { Header, Content } = Layout;

<Layout>
  <Header style={{ background: '#fff', padding: '0 24px' }}>
    <h2>欢迎, {user?.username}</h2>
  </Header>
  <Content style={{ padding: '24px' }}>
    {/* Table 组件 */}
  </Content>
</Layout>
```

**Loading 组件**:

```typescript
import { Spin } from 'antd';

{loading && <Spin tip="加载中..." />}
```

**Message API 使用**:

```typescript
import { message } from 'antd';

// 成功提示
message.success('已复制');

// 错误提示
message.error('加载失败: ' + error.message);
```

[Source: Ant Design 5.x 官方文档,技术栈选择 docs/architecture/tech-stack.md]

### API Client Service Pattern

**Service 层设计模式**:

根据编码规范,前端 API 调用必须通过 Service 层封装:

```typescript
// packages/frontend/src/services/endpoint.service.ts
import api from './api';  // Axios 实例,已配置 baseURL 和 interceptors
import type { EndpointWithUrl } from '@websocket-relay/shared/types/endpoint.types';

// 获取当前用户的所有端点
export async function getEndpoints(): Promise<EndpointWithUrl[]> {
  const response = await api.get<{ data: { endpoints: EndpointWithUrl[] } }>('/endpoints');
  return response.data.data.endpoints;
}
```

**API Client 配置** (假设已存在于 `packages/frontend/src/services/api.ts`):

```typescript
import axios from 'axios';

const api = axios.create({
  baseURL: import.meta.env.VITE_API_BASE_URL || 'http://localhost:3000/api',
});

// 请求拦截器:自动附加 JWT Token
api.interceptors.request.use((config) => {
  const token = localStorage.getItem('auth_token');
  if (token) {
    config.headers.Authorization = `Bearer ${token}`;
  }
  return config;
});

// 响应拦截器:统一错误处理
api.interceptors.response.use(
  (response) => response,
  (error) => {
    if (error.response?.status === 401) {
      // 未授权,跳转登录页
      localStorage.removeItem('auth_token');
      window.location.href = '/login';
    }
    return Promise.reject(error);
  }
);

export default api;
```

**关键规则**:

- **禁止直接使用 Axios**: 页面组件中禁止直接 `import axios`,必须通过 Service 层调用
- **类型安全**: Service 函数必须明确返回类型,使用 `packages/shared` 中的类型定义
- **错误传播**: Service 层不处理具体错误提示,将错误抛出给组件层处理

[Source: docs/architecture/coding-standards.md#Critical Fullstack Rules, docs/architecture/frontend-architecture.md#API Client]

### AuthContext Usage

**获取用户信息**:

根据前端架构文档,AuthContext 提供全局用户认证状态:

```typescript
// packages/frontend/src/contexts/AuthContext.tsx (已存在)
interface AuthContextType {
  user: UserPublic | null;
  isAuthenticated: boolean;
  login: (username: string, password: string) => Promise<void>;
  logout: () => void;
}

// 在组件中使用
import { useAuth } from '@/hooks/useAuth';

function DashboardPage() {
  const { user, isAuthenticated } = useAuth();

  return (
    <div>
      <h2>欢迎, {user?.username}</h2>
    </div>
  );
}
```

**UserPublic 类型定义** (已存在于 `packages/shared/src/types/user.types.ts`):

```typescript
interface UserPublic {
  id: string;
  username: string;
  email: string;
  is_admin: boolean;
  created_at: Date;
}
```

[Source: docs/architecture/components.md#AuthContext, docs/architecture/data-models.md#User]

### Date Formatting

**date-fns 库使用**:

根据技术栈文档,项目使用 `date-fns` 进行日期处理:

```typescript
import { format } from 'date-fns';

// 格式化创建时间
format(new Date(endpoint.created_at), 'yyyy-MM-dd HH:mm')
// 输出示例: "2025-10-28 10:30"

// 处理 nullable 的 last_active_at
endpoint.last_active_at
  ? format(new Date(endpoint.last_active_at), 'yyyy-MM-dd HH:mm')
  : '从未活跃'
```

[Source: docs/architecture/tech-stack.md#Technology Stack Table]

### Clipboard API

**复制到剪贴板**:

使用浏览器原生 Clipboard API:

```typescript
async function handleCopy(url: string) {
  try {
    await navigator.clipboard.writeText(url);
    message.success('已复制');
  } catch (error) {
    message.error('复制失败');
  }
}
```

**浏览器兼容性**: 现代浏览器(Chrome 66+, Firefox 63+, Safari 13.1+)原生支持,无需 polyfill。

### File Locations

**本故事需要创建的文件**:

```
packages/
├── frontend/
│   └── src/
│       ├── pages/
│       │   └── DashboardPage.tsx          # 新建: 端点管理主页面组件
│       ├── services/
│       │   └── endpoint.service.ts        # 新建: 端点 API Service
│       └── router.tsx                     # 修改: 添加 /dashboard 路由
```

**需要引用的现有文件**:

```
packages/
├── frontend/
│   └── src/
│       ├── contexts/
│       │   └── AuthContext.tsx            # 已存在: 用户认证上下文
│       ├── hooks/
│       │   └── useAuth.ts                 # 已存在: useAuth Hook
│       └── services/
│           └── api.ts                     # 已存在: Axios 实例配置
└── shared/
    └── src/
        └── types/
            ├── endpoint.types.ts          # 已存在: EndpointWithUrl 类型
            └── user.types.ts              # 已存在: UserPublic 类型
```

[Source: docs/architecture/unified-project-structure.md, docs/architecture/frontend-architecture.md#Component Organization]

### Coding Standards

**TypeScript 命名规范**:

| Element | Convention | Example |
|---------|-----------|---------|
| React 组件 | PascalCase | `DashboardPage.tsx` |
| Service 函数 | camelCase | `getEndpoints()` |
| 常量 | UPPER_SNAKE_CASE | `API_BASE_URL` |
| 接口/类型 | PascalCase | `EndpointWithUrl`, `UserPublic` |

**关键规则**:

- **Type Sharing**: 所有共享类型定义在 `packages/shared/src/types`
- **API Calls**: 所有 API 通过 Service 层调用,禁止直接使用 Axios
- **State Updates**: 禁止直接修改状态,使用 setState 或 Context API
- **Import Paths**: 使用 `@websocket-relay/shared` 导入共享类型

[Source: docs/architecture/coding-standards.md#Naming Conventions]

### Routing Configuration

**React Router 配置**:

根据前端架构文档,路由配置在 `packages/frontend/src/router.tsx`:

```typescript
import { createBrowserRouter } from 'react-router-dom';
import ProtectedRoute from '@/components/ProtectedRoute';
import DashboardPage from '@/pages/DashboardPage';

const router = createBrowserRouter([
  {
    path: '/login',
    element: <LoginPage />,
  },
  {
    path: '/dashboard',
    element: (
      <ProtectedRoute>
        <DashboardPage />
      </ProtectedRoute>
    ),
  },
  // ...其他路由
]);
```

**ProtectedRoute 组件** (假设已存在):

```typescript
// packages/frontend/src/components/ProtectedRoute.tsx
import { Navigate } from 'react-router-dom';
import { useAuth } from '@/hooks/useAuth';

function ProtectedRoute({ children }: { children: React.ReactNode }) {
  const { isAuthenticated } = useAuth();

  if (!isAuthenticated) {
    return <Navigate to="/login" replace />;
  }

  return <>{children}</>;
}
```

[Source: docs/architecture/frontend-architecture.md#Routing]

## Testing

### Test Organization

**本故事的测试策略**:

根据测试策略文档,前端测试为**可选**,MVP 阶段优先手动测试。

**手动测试检查清单**:

1. **页面加载测试**:
   - 访问 `/dashboard` 页面,验证页面正常渲染
   - 验证用户欢迎信息显示当前登录用户名
   - 验证"创建端点"按钮显示在页面顶部

2. **端点列表显示测试**:
   - 验证页面加载时显示 Spin 加载动画
   - 验证加载完成后显示端点列表
   - 验证 Table 显示所有必需列:端点名称、WebSocket URL、创建时间、最后活跃时间
   - 验证时间格式正确(yyyy-MM-dd HH:mm)
   - 验证 `last_active_at` 为 null 时显示"从未活跃"

3. **复制功能测试**:
   - 点击 WebSocket URL 旁边的"复制"按钮
   - 验证显示 `message.success('已复制')` 提示
   - 验证剪贴板内容为正确的 WebSocket URL

4. **空列表测试**:
   - 使用没有端点的账号登录
   - 验证显示 Empty 组件提示"还没有端点,点击创建按钮开始"

5. **错误处理测试**:
   - 模拟 API 请求失败(例如:停止后端服务)
   - 验证显示 `message.error()` 错误提示
   - 验证页面不崩溃,保持可用状态

6. **未认证测试**:
   - 清除 localStorage 中的 Token
   - 访问 `/dashboard` 页面
   - 验证自动重定向到登录页

**前端单元测试(可选,优先级较低)**:

如果需要编写单元测试,可在 `packages/frontend/src/__tests__/` 目录下创建:

```
packages/frontend/src/__tests__/
└── pages/
    └── DashboardPage.test.tsx  # 可选: 使用 Vitest + React Testing Library
```

[Source: docs/architecture/testing-strategy.md#Test Organization, docs/architecture/tech-stack.md#Technology Stack Table]

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-28 | 1.0 | 初始创建故事 2.5 | Bob (Scrum Master) |
| 2025-10-28 | 1.1 | 修复登录后立即失效的 Bug (BUG-2.5-001) | James (Dev Agent) |

## Dev Agent Record

### Agent Model Used

Claude Sonnet 4.5 (claude-sonnet-4-5-20250929)

### Debug Log References

**BUG-2.5-001: 登录后立即提示失效并返回登录页面**

**问题描述:**
- 用户登录成功后,立即被提示"登录已过期",并被重定向回登录页面
- 无法正常访问 Dashboard 页面

**根本原因:**
- 位置: `packages/frontend/src/services/auth.service.ts:40`
- 后端 API 返回格式: `{ data: { token, user } }`
- `api.ts` 响应拦截器已提取一层 `response.data`,返回 `{ data: { token, user } }`
- 但 `login()` 函数直接返回该结果,未再次提取内层的 `data` 字段
- 导致 `AuthContext` 中 `response.token` 和 `response.user` 为 `undefined`
- Token 未存储到 localStorage,用户状态未更新
- 登录后被视为"未认证",触发重定向到登录页

**修复方案:**
```typescript
// 修改前
export async function login(credentials: LoginRequest): Promise<LoginResponse> {
  return apiClient.post<LoginResponse>('/auth/login', credentials);
}

// 修改后
export async function login(credentials: LoginRequest): Promise<LoginResponse> {
  const response = (await apiClient.post<{ data: LoginResponse }>(
    '/auth/login',
    credentials
  )) as { data: LoginResponse };
  return response.data; // 正确提取嵌套的 data 字段
}
```

**验证结果:**
- ✅ 登录成功后正确跳转到 Dashboard
- ✅ Token 正确存储到 localStorage
- ✅ 用户状态正确更新
- ✅ Dashboard 正常加载端点列表
- ✅ 不再出现"登录失效"提示

### Completion Notes List

- 成功创建 `packages/frontend/src/services/endpoint.service.ts` 端点 API Service
- 成功更新 `packages/frontend/src/pages/DashboardPage.tsx` 实现完整的端点列表展示功能
- 路由配置 `/dashboard` 已存在,无需修改
- 所有 Acceptance Criteria 已完成验证
- 代码通过 ESLint 和 Prettier 检查
- API 集成测试通过,确认后端返回正确的端点数据
- **Bug 修复:** 修复了登录后立即失效的问题 (BUG-2.5-001)
  - 修改 `auth.service.ts` 的 `login()` 函数,正确提取嵌套的 data 字段
  - 验证登录流程完全正常工作

### File List

**新建文件:**
- `packages/frontend/src/services/endpoint.service.ts` - 端点 API Service 函数

**修改文件:**
- `packages/frontend/src/pages/DashboardPage.tsx` - 端点管理主页面组件(完整重写)
- `packages/frontend/src/services/auth.service.ts` - 修复 login 函数的数据提取逻辑 (Bug 修复)

## QA Results

待 QA 代理填写
