# Story 3.2: 实现端点 ID 解析和连接映射管理

## Status

**Done**

## Story

**As a** 后端开发者,
**I want** 从 WebSocket 连接 URL 中提取 endpoint_id 并建立映射关系,
**so that** 可以将消息路由到正确的端点。

## Acceptance Criteria

1. WebSocket 连接 URL 格式:`ws://localhost:3001/ws/{endpoint_id}`
2. 从连接请求的 URL 中解析出 endpoint_id(使用 `url.parse()` 或类似方法)
3. 如果 URL 格式不正确或缺少 endpoint_id,拒绝连接并发送错误消息
4. 验证 endpoint_id 在数据库中存在(查询 Prisma Endpoint 表)
5. 如果 endpoint_id 不存在,拒绝连接并发送 "Invalid endpoint" 错误
6. 创建内存 Map 数据结构:`Map<endpoint_id, Set<WebSocket>>`,存储端点到连接的映射
7. 连接建立时,将 WebSocket 对象添加到对应 endpoint_id 的 Set 中
8. 连接断开时,从 Set 中移除 WebSocket 对象
9. 使用 `wscat -c "ws://localhost:3001/ws/{valid_endpoint_id}"` 测试,验证连接成功
10. 使用无效 endpoint_id 测试,验证连接被拒绝

## Tasks / Subtasks

- [x] **Task 1: 创建 ConnectionManager 类管理连接映射** (AC: 6, 7, 8)
  - [x] 在 `packages/backend/src/websocket/` 创建 `connection-manager.ts` 文件
  - [x] 定义 `ConnectionManager` 类,内部维护 `Map<string, Set<WebSocket>>`
  - [x] 实现 `addConnection(endpointId: string, socket: WebSocket)` 方法
  - [x] 实现 `removeConnection(endpointId: string, socket: WebSocket)` 方法
  - [x] 实现 `getConnections(endpointId: string): Set<WebSocket>` 方法
  - [x] 实现 `hasConnection(endpointId: string, socket: WebSocket): boolean` 方法
  - [x] 导出 `ConnectionManager` 单例实例供全局使用

- [x] **Task 2: 在 WebSocket 服务器中解析 endpoint_id** (AC: 1, 2, 3)
  - [x] 在 `server.ts` 的 `connection` 事件处理器中获取请求 URL
  - [x] 使用 Node.js `url` 模块解析 URL:`url.parse(req.url!)`
  - [x] 提取路径部分,匹配格式 `/ws/{endpoint_id}`
  - [x] 使用正则表达式或字符串分割提取 endpoint_id:`/^\/ws\/([a-zA-Z0-9-]+)$/`
  - [x] 如果 URL 格式不正确或 endpoint_id 缺失,关闭连接:
    - 发送错误消息:`socket.send(JSON.stringify({ type: 'system', level: 'error', message: 'Invalid URL format' }))`
    - 调用 `socket.close(1008, 'Invalid URL format')`
  - [x] 将解析出的 `endpoint_id` 存储到 socket 对象的自定义属性中

- [x] **Task 3: 验证 endpoint_id 在数据库中存在** (AC: 4, 5)
  - [x] 导入 Prisma Client:`import { PrismaClient, Endpoint } from '@prisma/client'`
  - [x] 创建 Prisma 实例:`const prisma = new PrismaClient()`
  - [x] 在连接处理器中查询 Endpoint 表
  - [x] 如果 endpoint 为 null,拒绝连接并发送错误消息
  - [x] 将查询到的 endpoint 数据存储到 socket 对象

- [x] **Task 4: 集成 ConnectionManager 到连接/断开事件** (AC: 7, 8)
  - [x] 在 `server.ts` 中导入 ConnectionManager:`import { connectionManager } from './connection-manager'`
  - [x] 在验证 endpoint_id 成功后,调用 `connectionManager.addConnection(endpointId, socket)`
  - [x] 打印日志:`console.log(\`WebSocket connected to endpoint: \${endpointId}\`)`
  - [x] 在 `socket.on('close')` 事件处理器中调用 `connectionManager.removeConnection(endpointId, socket)`
  - [x] 打印日志:`console.log(\`WebSocket disconnected from endpoint: \${endpointId}\`)`
  - [x] 确保即使发生错误,也能正确移除连接(使用 try-catch)

- [x] **Task 5: 添加单元测试(可选)** - 跳过,使用手动测试替代

- [x] **Task 6-8: 综合手动测试** (AC: 3, 9, 10)
  - [x] 创建自动化测试脚本 `test-websocket-endpoints.mjs`
  - [x] 测试有效 endpoint_id 连接 (CV6e3sON9o)
  - [x] 测试无效 endpoint_id 连接 (invalid-endpoint-id)
  - [x] 测试缺少 endpoint_id (`/ws/`)
  - [x] 测试错误路径 (`/invalid/path`)
  - [x] 测试根路径 (`/`)
  - [x] 所有测试通过,验证连接管理和错误处理正常

- [x] **Task 9: 代码规范检查**
  - [x] 运行 `pnpm lint` 检查代码风格
  - [x] 运行 `pnpm format` 格式化代码
  - [x] 确保所有新文件符合 TypeScript 编码规范

## Dev Notes

### Previous Story Insights

**从 Story 3.1 中学到的关键经验:**

1. **代码规范一致性**:
   - 必须运行 lint 和 format 检查,确保代码符合团队规范
   - 及时修复 ESLint 错误,不能留下警告

2. **文件路径对齐**:
   - 严格遵循项目结构文档定义的目录结构
   - 所有新文件必须放在正确的位置

3. **独立测试**:
   - 每个功能都必须进行手动测试验证
   - 不能假设代码能运行,必须实际启动测试

4. **依赖已安装**:
   - ws@8.18.3 和 @types/ws@8.18.1 已经在 Story 3.1 中安装
   - WebSocket 服务器基础框架已经搭建完成

5. **现有文件结构**:
   - `packages/backend/src/websocket/server.ts` 已存在
   - `packages/backend/src/ws-server.ts` 已存在(启动入口)

[Previous Story: docs/stories/3.1.story.md]

---

### WebSocket URL Parsing

**URL 格式定义:**

根据 Epic 3 Story 3.2 的 AC 1,WebSocket 连接 URL 的标准格式为:

```
ws://localhost:3001/ws/{endpoint_id}
```

**示例:**
- 有效 URL:`ws://localhost:3001/ws/abc123xyz`
- 无效 URL:`ws://localhost:3001/` (缺少 endpoint_id)
- 无效 URL:`ws://localhost:3001/invalid/path` (路径格式错误)

**解析方法:**

使用 Node.js 内置的 `url` 模块解析 WebSocket 请求的 URL:

```typescript
import url from 'url';

wss.on('connection', (socket: WebSocket, req: IncomingMessage) => {
  const parsedUrl = url.parse(req.url!);
  const pathname = parsedUrl.pathname; // 例如: "/ws/abc123xyz"

  // 提取 endpoint_id
  const match = pathname?.match(/^\/ws\/([a-zA-Z0-9]+)$/);
  const endpointId = match ? match[1] : null;

  if (!endpointId) {
    socket.send(JSON.stringify({
      type: 'system',
      level: 'error',
      message: 'Invalid URL format'
    }));
    socket.close(1008, 'Invalid URL format');
    return;
  }

  // 继续处理...
});
```

**关键设计点:**

1. **正则表达式验证**:使用 `/^\/ws\/([a-zA-Z0-9]+)$/` 确保路径格式正确
2. **提取捕获组**:`match[1]` 包含提取的 endpoint_id
3. **错误处理**:如果匹配失败,立即拒绝连接并发送错误消息
4. **WebSocket 关闭代码**:使用 `1008` (Policy Violation) 表示 URL 格式错误

[Source: Epic 3 Story 3.2 AC 1-3, Node.js url 模块文档]

---

### Endpoint Validation with Prisma

**数据库查询:**

根据 database-schema.md 和 data-models.md,Endpoint 表的结构如下:

```prisma
model Endpoint {
  id             String    @id @default(uuid())
  endpoint_id    String    @unique @db.VarChar(12)
  name           String    @default("未命名端点") @db.VarChar(100)
  user_id        String
  created_at     DateTime  @default(now())
  last_active_at DateTime?

  user  User           @relation(fields: [user_id], references: [id], onDelete: Cascade)
  stats EndpointStats?

  @@index([endpoint_id])
  @@map("endpoints")
}
```

**验证逻辑:**

使用 Prisma Client 查询 endpoint_id 是否存在:

```typescript
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

const endpoint = await prisma.endpoint.findUnique({
  where: { endpoint_id: endpointId }
});

if (!endpoint) {
  socket.send(JSON.stringify({
    type: 'system',
    level: 'error',
    message: 'Invalid endpoint'
  }));
  socket.close(1008, 'Invalid endpoint');
  return;
}
```

**关键字段说明:**

- **endpoint_id**:用户可见的短 ID,用于 WebSocket URL(例如:`abc123xyz`)
- **id**:数据库内部主键(UUID)
- **user_id**:端点所属用户的 ID

**查询优化:**

- `endpoint_id` 字段有唯一索引 `@@index([endpoint_id])`,查询性能高
- 使用 `findUnique` 而不是 `findFirst`,因为 endpoint_id 有 `@unique` 约束

[Source: docs/architecture/database-schema.md, docs/architecture/data-models.md#Endpoint]

---

### ConnectionManager Architecture

**设计模式:**

根据 backend-architecture.md,WebSocket 服务器使用 ConnectionManager 管理连接池。

**数据结构:**

```typescript
Map<endpoint_id: string, Set<WebSocket>>
```

- **Key**:endpoint_id(字符串)
- **Value**:该端点的所有 WebSocket 连接集合(Set)

**为什么使用 Set:**

1. **自动去重**:同一个 WebSocket 对象不会被重复添加
2. **高效查找**:检查连接是否存在的时间复杂度为 O(1)
3. **高效删除**:移除连接的时间复杂度为 O(1)

**ConnectionManager 类设计:**

```typescript
// packages/backend/src/websocket/connection-manager.ts
import { WebSocket } from 'ws';

class ConnectionManager {
  private connections: Map<string, Set<WebSocket>> = new Map();

  addConnection(endpointId: string, socket: WebSocket): void {
    if (!this.connections.has(endpointId)) {
      this.connections.set(endpointId, new Set());
    }
    this.connections.get(endpointId)!.add(socket);
  }

  removeConnection(endpointId: string, socket: WebSocket): void {
    const sockets = this.connections.get(endpointId);
    if (sockets) {
      sockets.delete(socket);
      if (sockets.size === 0) {
        this.connections.delete(endpointId); // 清理空的 Set
      }
    }
  }

  getConnections(endpointId: string): Set<WebSocket> {
    return this.connections.get(endpointId) || new Set();
  }

  hasConnection(endpointId: string, socket: WebSocket): boolean {
    return this.connections.get(endpointId)?.has(socket) || false;
  }
}

// 导出单例实例
export const connectionManager = new ConnectionManager();
```

**单例模式:**

- 全局只有一个 ConnectionManager 实例
- 所有 WebSocket 连接共享同一个连接池
- 导出 `connectionManager` 供其他模块使用

**内存清理:**

- 当某个 endpoint 的所有连接都断开时,自动删除该 endpoint 的 Map 条目
- 防止内存泄漏,保持 Map 的大小与活跃端点数量一致

[Source: docs/architecture/backend-architecture.md#WebSocket Server]

---

### Socket Custom Properties

**存储额外信息到 WebSocket 对象:**

WebSocket 库的 `WebSocket` 对象不包含 endpoint_id 等自定义信息,需要手动添加。

**方法:**

使用 TypeScript 类型断言将自定义属性附加到 socket 对象:

```typescript
(socket as any).endpointId = endpointId;
(socket as any).endpoint = endpoint; // Endpoint 数据库对象
```

**用途:**

1. **在断开事件中获取 endpoint_id**:
   ```typescript
   socket.on('close', () => {
     const endpointId = (socket as any).endpointId;
     connectionManager.removeConnection(endpointId, socket);
   });
   ```

2. **在消息事件中访问端点信息**:
   ```typescript
   socket.on('message', (data) => {
     const endpoint = (socket as any).endpoint;
     console.log(`Message from endpoint: ${endpoint.name}`);
   });
   ```

**更好的类型安全方案(可选):**

定义扩展接口:

```typescript
interface ExtendedWebSocket extends WebSocket {
  endpointId?: string;
  endpoint?: Endpoint;
}

// 使用时类型断言
const extSocket = socket as ExtendedWebSocket;
extSocket.endpointId = endpointId;
extSocket.endpoint = endpoint;
```

**注意事项:**

- 这种方法在 MVP 阶段足够,未来可以使用 `WeakMap` 存储元数据
- 不要在自定义属性中存储敏感信息(如密码),只存储必要的标识符

[Source: 行业最佳实践,TypeScript 编程惯例]

---

### Error Handling for WebSocket Connections

**错误消息格式:**

根据 data-models.md 定义的 SystemMessage 接口:

```typescript
interface SystemMessage {
  type: 'system';
  message: string;
  level: 'info' | 'error' | 'warning';
  timestamp: number;
}
```

**发送错误消息的标准方法:**

```typescript
socket.send(JSON.stringify({
  type: 'system',
  level: 'error',
  message: 'Invalid endpoint',
  timestamp: Date.now()
}));
```

**WebSocket 关闭代码:**

根据 WebSocket 协议规范,使用以下关闭代码:

| 代码 | 含义 | 使用场景 |
|------|------|----------|
| 1000 | Normal Closure | 正常关闭连接 |
| 1008 | Policy Violation | URL 格式错误、endpoint 不存在 |
| 1011 | Internal Error | 服务器内部错误 |

**错误处理流程:**

1. **检测错误**:URL 格式错误或 endpoint_id 不存在
2. **发送错误消息**:使用 SystemMessage 格式通知客户端
3. **关闭连接**:`socket.close(1008, 'Error reason')`
4. **记录日志**:`console.error('Connection rejected: Invalid endpoint')`
5. **立即返回**:不执行后续的连接添加逻辑

**示例:**

```typescript
if (!endpoint) {
  console.error(`Connection rejected: Invalid endpoint_id ${endpointId}`);
  socket.send(JSON.stringify({
    type: 'system',
    level: 'error',
    message: 'Invalid endpoint',
    timestamp: Date.now()
  }));
  socket.close(1008, 'Invalid endpoint');
  return; // 关键:立即返回,不执行后续逻辑
}
```

[Source: docs/architecture/data-models.md#WebSocketMessage, WebSocket RFC 6455]

---

### Project Structure Alignment

**本故事需要创建/修改的文件:**

根据 unified-project-structure.md,文件路径如下:

```
packages/backend/src/websocket/
├── server.ts                 # 修改:添加 URL 解析和验证逻辑
├── connection-manager.ts     # 新建:连接管理器类
└── (其他文件在后续故事中创建)
```

**文件职责:**

- **`connection-manager.ts`**:封装连接映射管理逻辑,提供 add/remove/get 方法
- **`server.ts`**:WebSocket 服务器主文件,集成 ConnectionManager

**导入路径:**

```typescript
// 在 server.ts 中导入
import { connectionManager } from './connection-manager';
```

**测试文件(可选):**

```
packages/backend/tests/websocket/
└── connection-manager.test.ts  # 新建:ConnectionManager 单元测试
```

[Source: docs/architecture/unified-project-structure.md]

---

### Prisma Client Integration

**Prisma Client 导入:**

根据 coding-standards.md,所有数据库查询必须使用 Prisma。

**导入方式:**

```typescript
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();
```

**查询示例:**

```typescript
const endpoint = await prisma.endpoint.findUnique({
  where: { endpoint_id: endpointId }
});
```

**类型安全:**

- Prisma 自动生成 TypeScript 类型,`endpoint` 的类型为 `Endpoint | null`
- 使用 `if (!endpoint)` 进行空值检查

**连接管理:**

- **开发环境**:每次导入 `PrismaClient` 都会创建新实例,开发时无问题
- **生产环境**:应使用单例模式避免连接池耗尽(后续优化)

**异步处理:**

- WebSocket 的 `connection` 事件处理器需要改为 `async`:
  ```typescript
  wss.on('connection', async (socket: WebSocket, req: IncomingMessage) => {
    // 可以使用 await 查询数据库
  });
  ```

[Source: docs/architecture/coding-standards.md#Database Queries, Prisma 文档]

---

### Testing Tools: wscat

**wscat 使用方法:**

wscat 在 Story 3.1 中已经介绍,本故事重点测试 URL 参数。

**测试命令:**

1. **有效 endpoint_id 连接:**
   ```bash
   wscat -c "ws://localhost:3001/ws/abc123xyz"
   ```

2. **无效 endpoint_id 连接:**
   ```bash
   wscat -c "ws://localhost:3001/ws/invalid-id"
   ```

3. **缺少 endpoint_id:**
   ```bash
   wscat -c "ws://localhost:3001/ws/"
   ```

4. **错误路径:**
   ```bash
   wscat -c "ws://localhost:3001/invalid/path"
   ```

**预期结果验证:**

- **成功连接**:wscat 显示 "Connected",服务器打印连接日志
- **拒绝连接**:wscat 收到错误消息,连接立即断开

**获取有效 endpoint_id 的方法:**

使用 Prisma Studio 或数据库查询:

```bash
# 启动 Prisma Studio
npx prisma studio

# 或使用数据库查询
mysql -u root -p
USE websocket_relay;
SELECT endpoint_id FROM endpoints LIMIT 1;
```

[Source: AC 9, AC 10, Story 3.1 测试经验]

---

### Coding Standards Compliance

**TypeScript 命名规范:**

| Element | Convention | Example |
|---------|-----------|---------|
| 类名 | PascalCase | `ConnectionManager` |
| 文件名 | kebab-case | `connection-manager.ts` |
| 方法名 | camelCase | `addConnection()` |
| 变量名 | camelCase | `endpointId`, `socket` |
| 常量 | UPPER_SNAKE_CASE | `MAX_CONNECTIONS` |

**导入规范:**

- 使用 ES6 导入语法:`import { WebSocket } from 'ws'`
- 导入顺序:第三方库 → 本地模块 → 类型定义

**错误处理:**

- 所有数据库查询使用 try-catch 包裹
- WebSocket 错误必须记录日志,不能静默失败

**代码检查:**

- 运行 `pnpm lint` 检查代码风格
- 运行 `pnpm format` 自动格式化代码
- 确保没有 ESLint 警告或错误

[Source: docs/architecture/coding-standards.md#Naming Conventions]

---

## Testing

### Test Organization

**本故事的测试策略:**

根据测试策略文档,本故事优先使用**手动测试**,单元测试为可选。

**手动测试检查清单:**

1. **有效 endpoint_id 连接测试 (AC 9):**
   - 获取一个有效的 endpoint_id(使用 Prisma Studio 或数据库查询)
   - 启动 WebSocket 服务器:`pnpm --filter @websocket-relay/backend ws-server`
   - 使用 wscat 连接:`wscat -c "ws://localhost:3001/ws/{valid_endpoint_id}"`
   - 验证连接成功,wscat 显示 "Connected"
   - 验证服务器打印:`WebSocket connected to endpoint: {valid_endpoint_id}`
   - 断开连接(CTRL+C)
   - 验证服务器打印:`WebSocket disconnected from endpoint: {valid_endpoint_id}`

2. **无效 endpoint_id 连接测试 (AC 10):**
   - 使用 wscat 连接到不存在的 endpoint_id:`wscat -c "ws://localhost:3001/ws/invalid-endpoint-id"`
   - 验证 wscat 收到错误消息:`{ "type": "system", "level": "error", "message": "Invalid endpoint" }`
   - 验证连接被立即关闭,wscat 显示 "Disconnected"
   - 验证服务器打印错误日志,但没有 "WebSocket connected" 日志

3. **URL 格式错误测试 (AC 3):**
   - 测试缺少 endpoint_id:`wscat -c "ws://localhost:3001/ws/"`
   - 验证收到错误消息:`{ "type": "system", "level": "error", "message": "Invalid URL format" }`
   - 验证连接被立即关闭
   - 测试错误路径:`wscat -c "ws://localhost:3001/invalid/path"`
   - 验证收到错误消息并断开连接
   - 测试直接连接根路径:`wscat -c "ws://localhost:3001/"`
   - 验证收到错误消息并断开连接

4. **多客户端连接同一端点测试:**
   - 打开 3 个终端窗口
   - 分别使用 wscat 连接到同一个有效的 endpoint_id
   - 验证所有连接都成功建立
   - 验证服务器打印 3 次连接日志
   - 依次断开连接
   - 验证服务器打印 3 次断开日志

5. **ConnectionManager 功能测试:**
   - 使用 Prisma Studio 获取两个不同的有效 endpoint_id:endpoint_A 和 endpoint_B
   - 使用 wscat 连接到 endpoint_A(2 个客户端)
   - 使用 wscat 连接到 endpoint_B(2 个客户端)
   - 验证所有连接都成功建立
   - 在代码中添加临时日志,打印 ConnectionManager 的内部状态:
     ```typescript
     console.log('Connections:', Array.from(connectionManager['connections'].keys()));
     ```
   - 验证 Map 中有两个 key:endpoint_A 和 endpoint_B
   - 断开 endpoint_A 的所有连接
   - 验证 Map 中只剩下 endpoint_B

**单元测试(可选):**

如果需要编写单元测试,可在 `packages/backend/tests/websocket/` 目录下创建:

```
packages/backend/tests/websocket/
└── connection-manager.test.ts
```

**测试框架:**

- 使用 **Jest** 作为测试框架
- 测试 ConnectionManager 的各个方法
- 参考 `docs/architecture/testing-strategy.md` 中的示例

**单元测试示例:**

```typescript
// tests/websocket/connection-manager.test.ts
import { WebSocket } from 'ws';
import { connectionManager } from '@/websocket/connection-manager';

describe('ConnectionManager', () => {
  it('应该成功添加连接', () => {
    const socket = new WebSocket('ws://localhost:3001');
    connectionManager.addConnection('test-endpoint', socket);

    const connections = connectionManager.getConnections('test-endpoint');
    expect(connections.size).toBe(1);
    expect(connections.has(socket)).toBe(true);
  });

  it('应该成功移除连接', () => {
    const socket = new WebSocket('ws://localhost:3001');
    connectionManager.addConnection('test-endpoint', socket);
    connectionManager.removeConnection('test-endpoint', socket);

    const connections = connectionManager.getConnections('test-endpoint');
    expect(connections.size).toBe(0);
  });
});
```

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-28 | 1.0 | 初始创建故事 3.2 | Bob (Scrum Master) |
| 2025-10-28 | 1.1 | 完成所有开发任务,状态更新为 Ready for Review | James (Dev Agent) |

## Dev Agent Record

### Agent Model Used

Claude Sonnet 4.5 (claude-sonnet-4-5-20250929)

### Debug Log References

无

### Completion Notes List

1. **ExtendedWebSocket 接口**: 为了解决 TypeScript 类型安全问题,定义了 `ExtendedWebSocket` 接口扩展 WebSocket,包含 `endpointId` 和 `endpoint` 属性
2. **异步处理包装**: 将 async 连接处理逻辑包装在 `handleConnection` 函数中,使用 `void` 运算符显式忽略 Promise,避免 ESLint 错误
3. **正则表达式更新**: 在 URL 匹配正则中添加了对连字符 `-` 的支持:`/^\/ws\/([a-zA-Z0-9-]+)$/`
4. **错误处理完善**: 所有错误场景都返回标准的 SystemMessage 格式,并使用正确的 WebSocket 关闭代码 (1008/1011)
5. **测试方法**: 创建了自动化测试脚本 `test-websocket-endpoints.mjs`,覆盖所有 AC,替代手动 wscat 测试

### File List

**新增文件:**
- `packages/backend/src/websocket/connection-manager.ts` - ConnectionManager 单例类
- `packages/backend/test-websocket-endpoints.mjs` - 自动化测试脚本 (临时测试文件)

**修改文件:**
- `packages/backend/src/websocket/server.ts` - 添加 URL 解析、数据库验证、连接管理集成

## QA Results

待 QA 代理填写
