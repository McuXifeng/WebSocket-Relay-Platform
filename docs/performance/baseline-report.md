# WebSocket Relay Platform - 性能基准测试报告

**版本**: v1.0
**测试日期**: 2025-11-02
**测试工具**: Artillery 2.0.21
**报告生成时间**: (待更新)

---

## 📋 执行摘要

本报告记录了 WebSocket Relay Platform 的首次性能基准测试结果。测试涵盖了4个核心场景,旨在评估系统当前的性能表现并识别潜在瓶颈。

**关键发现**:
- (待更新: 测试完成后填写)

**推荐优化方向**:
- (待更新: 根据测试结果填写)

---

## 🖥️ 测试环境

### 硬件配置

| 组件 | 规格 |
|------|------|
| 操作系统 | Windows 11 / macOS / Ubuntu 20.04 (根据实际填写) |
| CPU | (待填写: 例如 Intel Core i7-10700K @ 3.80GHz, 8 核 16 线程) |
| 内存 | (待填写: 例如 16GB DDR4 3200MHz) |
| 硬盘 | (待填写: 例如 NVMe SSD 500GB) |
| 网络 | 本地网络 (localhost) |

### 软件版本

| 软件 | 版本 |
|------|------|
| Node.js | v22.12.0 (根据实际版本填写) |
| MySQL | 8.0+ |
| Prisma | 5.8.1 |
| WebSocket (ws) | 8.18.3 |
| Artillery | 2.0.21 |

### 数据库配置

- 数据库引擎: MySQL 8.0
- 连接池大小: 默认 (Prisma 管理)
- 索引: 按照 `schema.prisma` 定义

---

## 📊 测试场景和结果

### 场景 1: 单端点多连接测试

**测试目的**: 评估单个端点在不同并发连接数下的性能表现

**测试配置**:
- 端点数量: 1 个固定端点 (`perf-test-endpoint-1`)
- 并发连接数: 10 → 20 → 50 (逐步增加)
- 测试时长: 预热 60s + 每阶段 120s,共 7 分钟
- 消息频率: 每连接 1 msg/s

**测试结果**:

| 并发连接数 | p50延迟 (ms) | p95延迟 (ms) | p99延迟 (ms) | 平均吞吐量 (msg/s) | CPU使用率 (%) | 内存使用 (MB) | 错误率 (%) |
|----------|-------------|-------------|-------------|------------------|-------------|-------------|-----------|
| 10       | (待填写)    | (待填写)    | (待填写)    | (待填写)         | (待填写)    | (待填写)    | (待填写)  |
| 20       | (待填写)    | (待填写)    | (待填写)    | (待填写)         | (待填写)    | (待填写)    | (待填写)  |
| 50       | (待填写)    | (待填写)    | (待填写)    | (待填写)         | (待填写)    | (待填写)    | (待填写)  |

**观察和分析**:
- (待填写: 例如 "50 并发连接时 CPU 使用率接近目标上限(70%)")
- (待填写: 例如 "p99 延迟在 50 连接时超过 100ms 目标")
- (待填写: 内存增长趋势分析)

**与目标性能对比**:
- ✅ / ❌ p95 延迟 < 100ms
- ✅ / ❌ CPU 使用率 < 70% (50 连接时)
- ✅ / ❌ 错误率 < 1%

---

### 场景 2: 多端点并发测试

**测试目的**: 评估多个端点同时处理连接时的系统性能

**测试配置**:
- 端点数量: 10 → 50 → 100 个随机端点
- 每端点连接数: 5
- 总连接数: 50 → 250 → 500
- 测试时长: 预热 60s + 每阶段 120s,共 7 分钟
- 消息频率: 每连接 0.5 msg/s

**测试结果**:

| 端点数 | 总连接数 | p50延迟 (ms) | p95延迟 (ms) | p99延迟 (ms) | 平均吞吐量 (msg/s) | CPU使用率 (%) | 内存使用 (MB) | 错误率 (%) |
|-------|---------|-------------|-------------|-------------|------------------|-------------|-------------|-----------|
| 10    | 50      | (待填写)    | (待填写)    | (待填写)    | (待填写)         | (待填写)    | (待填写)    | (待填写)  |
| 50    | 250     | (待填写)    | (待填写)    | (待填写)    | (待填写)         | (待填写)    | (待填写)    | (待填写)  |
| 100   | 500     | (待填写)    | (待填写)    | (待填写)    | (待填写)         | (待填写)    | (待填写)    | (待填写)  |

**观察和分析**:
- (待填写: 例如 "100 端点(500 连接)时 CPU 使用率超过目标(70%)")
- (待填写: 连接池管理效率分析)
- (待填写: 内存泄漏检查结果)

**与目标性能对比**:
- ✅ / ❌ 支持 50+ 端点,每端点 10 连接
- ✅ / ❌ p95 延迟 < 300ms
- ✅ / ❌ 错误率 < 2%

---

### 场景 3: 高消息吞吐量测试

**测试目的**: 评估系统在高频消息场景下的吞吐能力

**测试配置**:
- 固定连接数: 50
- 目标吞吐量: 100 msg/s → 500 msg/s → 1000 msg/s
- 测试时长: 预热 60s + 每阶段 120s,共 7 分钟
- 实现方式: 调整每连接消息发送频率

**测试结果**:

| 目标吞吐量 (msg/s) | 实际吞吐量 (msg/s) | p50延迟 (ms) | p95延迟 (ms) | p99延迟 (ms) | CPU使用率 (%) | 内存使用 (MB) | 错误率 (%) |
|------------------|------------------|-------------|-------------|-------------|-------------|-------------|-----------|
| 100              | (待填写)         | (待填写)    | (待填写)    | (待填写)    | (待填写)    | (待填写)    | (待填写)  |
| 500              | (待填写)         | (待填写)    | (待填写)    | (待填写)    | (待填写)    | (待填写)    | (待填写)  |
| 1000             | (待填写)         | (待填写)    | (待填写)    | (待填写)    | (待填写)    | (待填写)    | (待填写)  |

**观察和分析**:
- (待填写: 吞吐量瓶颈分析)
- (待填写: JSON 序列化/反序列化开销)
- (待填写: 数据库写入性能影响)

**与目标性能对比**:
- ✅ / ❌ 达到 500+ msg/s 吞吐量
- ✅ / ❌ p99 延迟 < 500ms
- ✅ / ❌ 错误率 < 5%

---

### 场景 4: 长连接稳定性测试

**测试目的**: 评估系统长时间运行的稳定性和资源管理能力

**测试配置**:
- 并发连接数: 100
- 测试时长: 60 分钟
- 消息频率: 低频心跳 (每 10 秒 1 条)
- 额外测试: 20% 连接会经历断线重连

**测试结果**:

| 指标 | 值 |
|------|-----|
| 测试时长 | 60 分钟 |
| 总连接数 | 100 |
| 总消息数 | (待填写) |
| p50 延迟 (ms) | (待填写) |
| p95 延迟 (ms) | (待填写) |
| p99 延迟 (ms) | (待填写) |
| 平均 CPU 使用率 (%) | (待填写) |
| 峰值 CPU 使用率 (%) | (待填写) |
| 初始内存 (MB) | (待填写) |
| 最终内存 (MB) | (待填写) |
| 内存增长 (MB) | (待填写) |
| 进程重启次数 | (待填写) |
| 错误率 (%) | (待填写) |

**稳定性指标**:

| 时间段 | CPU (%) | 内存 (MB) | 延迟 p95 (ms) | 错误数 |
|-------|---------|-----------|--------------|--------|
| 0-15min | (待填写) | (待填写) | (待填写) | (待填写) |
| 15-30min | (待填写) | (待填写) | (待填写) | (待填写) |
| 30-45min | (待填写) | (待填写) | (待填写) | (待填写) |
| 45-60min | (待填写) | (待填写) | (待填写) | (待填写) |

**观察和分析**:
- (待填写: 内存泄漏检查结果)
- (待填写: 连接断线重连处理效果)
- (待填写: 长期运行稳定性评估)

**与目标性能对比**:
- ✅ / ❌ 无进程崩溃或重启
- ✅ / ❌ 无内存泄漏 (内存增长 < 10%)
- ✅ / ❌ p99 延迟 < 300ms
- ✅ / ❌ 错误率 < 1%

---

## 🔍 性能瓶颈分析

### 已识别的瓶颈

1. **数据库写入频繁** (优先级: 高)
   - **现象**: (待填写: 例如 "每条消息都触发 EndpointStats 更新,高并发时数据库成为瓶颈")
   - **影响**: (待填写: 例如 "在 500+ msg/s 场景下,数据库响应时间超过 50ms")
   - **建议**: 实现批量更新统计数据 (参考 Story 9.2)

2. **连接池遍历开销** (优先级: 中)
   - **现象**: (待填写: 例如 "广播消息时遍历 Set,连接数多时效率低")
   - **影响**: (待填写)
   - **建议**: 优化消息广播算法 (参考 Story 9.3)

3. **JSON 序列化开销** (优先级: 中)
   - **现象**: (待填写: 例如 "大量消息时 JSON.parse/stringify 占用 CPU")
   - **影响**: (待填写)
   - **建议**: 考虑使用二进制协议或优化 JSON 处理

### 性能指标汇总

**系统资源使用**:

| 场景 | 最大 CPU (%) | 平均 CPU (%) | 最大内存 (MB) | 平均内存 (MB) |
|------|-------------|-------------|--------------|--------------|
| 场景 1 (50 连接) | (待填写) | (待填写) | (待填写) | (待填写) |
| 场景 2 (500 连接) | (待填写) | (待填写) | (待填写) | (待填写) |
| 场景 3 (1000 msg/s) | (待填写) | (待填写) | (待填写) | (待填写) |
| 场景 4 (60min) | (待填写) | (待填写) | (待填写) | (待填写) |

**数据库性能**:

| 场景 | 平均查询时间 (ms) | 慢查询数量 (>100ms) | 总查询数 |
|------|-----------------|-------------------|---------|
| 场景 1 | (待填写) | (待填写) | (待填写) |
| 场景 2 | (待填写) | (待填写) | (待填写) |
| 场景 3 | (待填写) | (待填写) | (待填写) |
| 场景 4 | (待填写) | (待填写) | (待填写) |

---

## 📈 与目标性能对比

### 目标性能指标 (来自 Epic 9)

| 指标 | 目标值 | 当前值 | 状态 |
|------|--------|--------|------|
| 支持端点数 | 50+ | (待填写) | ✅ / ❌ |
| 每端点连接数 | 10 | (待填写) | ✅ / ❌ |
| 消息延迟 p95 | < 100ms | (待填写) | ✅ / ❌ |
| 消息吞吐量 | > 500 msg/s | (待填写) | ✅ / ❌ |
| CPU 使用率 | < 70% | (待填写) | ✅ / ❌ |
| 内存稳定性 | 无泄漏 | (待填写) | ✅ / ❌ |
| 系统稳定性 | 无崩溃 | (待填写) | ✅ / ❌ |

---

## 🚀 下一步优化方向

基于测试结果,建议按以下优先级进行优化:

### 高优先级 (Story 9.2)
- [ ] 实现批量更新统计数据,减少数据库写入频率
- [ ] 优化数据库查询,添加必要的索引
- [ ] 实现连接池状态缓存,减少实时查询

### 中优先级 (Story 9.3)
- [ ] 优化消息广播算法,减少遍历开销
- [ ] 实现消息队列,异步处理非关键任务
- [ ] 优化 JSON 序列化/反序列化

### 低优先级 (Story 9.4+)
- [ ] 考虑使用 PM2 集群模式提升并发能力
- [ ] 实现 Redis 缓存,减轻数据库压力
- [ ] 引入 WebSocket 二进制协议

---

## 📝 测试报告生成说明

### 如何更新此报告

1. 运行性能测试:
   ```bash
   cd packages/backend
   pnpm test:performance
   ```

2. 收集测试结果:
   - Artillery 报告: `tests/performance/reports/*.json`
   - 系统指标: `tests/performance/reports/metrics.json`
   - 数据库日志: `tests/performance/reports/query-performance.json`

3. 更新此文档中的 "(待填写)" 部分

4. 生成可视化图表 (可选):
   - 使用 Excel 打开 `metrics.csv`
   - 创建折线图展示 CPU/内存趋势
   - 创建柱状图对比不同场景的性能

---

## 附录

### 附录 A: 测试数据文件

- Artillery 原始报告: `packages/backend/tests/performance/reports/*.json`
- 系统指标数据: `packages/backend/tests/performance/reports/metrics.{json,csv}`
- 数据库查询日志: `packages/backend/tests/performance/reports/query-performance.json`
- Winston 性能日志: `packages/backend/tests/performance/reports/logs/*.log`

### 附录 B: 测试环境配置

- 测试数据库: `mysql://root:password@localhost:3306/websocket_relay_test`
- WebSocket 服务器: `ws://localhost:3001`
- 测试配置文件: `packages/backend/tests/performance/config.ts`

### 附录 C: 已知限制

- 测试在本地环境运行,网络延迟为零,实际生产环境延迟会更高
- 数据库未启用慢查询日志,部分查询性能数据可能不完整
- 测试未包含多服务器部署场景

---

**报告维护者**: 米醋电子工作室
**下次更新**: (实际运行测试后更新)
